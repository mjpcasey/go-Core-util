package msgp

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *AdapterRequest) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			z.AdxSpotId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AdxSpotId")
				return
			}
		case "2":
			z.AdxId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "AdxId")
				return
			}
		case "3":
			z.AdxUID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AdxUID")
				return
			}
		case "6":
			z.ReqId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ReqId")
				return
			}
		case "7":
			z.CmUserId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CmUserId")
				return
			}
		case "8":
			z.Url, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Url")
				return
			}
		case "9":
			z.Referer, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Referer")
				return
			}
		case "64":
			z.Search, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Search")
				return
			}
		case "10":
			z.Width, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Width")
				return
			}
		case "11":
			z.Height, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Height")
				return
			}
		case "12":
			z.SpotSize, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SpotSize")
				return
			}
		case "13":
			z.Minduration, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Minduration")
				return
			}
		case "14":
			z.Maxduration, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Maxduration")
				return
			}
		case "15":
			z.StartDelay, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "StartDelay")
				return
			}
		case "62":
			z.Linearity, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Linearity")
				return
			}
		case "63":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Zoom")
				return
			}
			if cap(z.Zoom) >= int(zb0002) {
				z.Zoom = (z.Zoom)[:zb0002]
			} else {
				z.Zoom = make([]string, zb0002)
			}
			for za0001 := range z.Zoom {
				z.Zoom[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Zoom", za0001)
					return
				}
			}
		case "16":
			z.Bidfloor, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Bidfloor")
				return
			}
		case "18":
			z.ViewType, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ViewType")
				return
			}
		case "19":
			z.Screen, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Screen")
				return
			}
		case "20":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "CreativeType")
				return
			}
			if cap(z.CreativeType) >= int(zb0003) {
				z.CreativeType = (z.CreativeType)[:zb0003]
			} else {
				z.CreativeType = make([]int, zb0003)
			}
			for za0002 := range z.CreativeType {
				z.CreativeType[za0002], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "CreativeType", za0002)
					return
				}
			}
		case "21":
			z.MaterialRenderType, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MaterialRenderType")
				return
			}
		case "22":
			z.Category, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Category")
				return
			}
		case "23":
			z.Ua, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Ua")
				return
			}
		case "24":
			z.Ip, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Ip")
				return
			}
		case "25":
			z.Ipv6, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Ipv6")
				return
			}
		case "26":
			z.GeoLat, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "GeoLat")
				return
			}
		case "27":
			z.GeoLon, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "GeoLon")
				return
			}
		case "28":
			z.Standard, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Standard")
				return
			}
		case "29":
			z.Carrier, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Carrier")
				return
			}
		case "30":
			z.Language, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Language")
				return
			}
		case "31":
			z.Browser, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Browser")
				return
			}
		case "33":
			z.Brand, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Brand")
				return
			}
		case "34":
			z.Model, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Model")
				return
			}
		case "36":
			z.Os, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Os")
				return
			}
		case "37":
			z.Osv, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Osv")
				return
			}
		case "40":
			z.Network, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Network")
				return
			}
		case "41":
			z.DeviceType, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DeviceType")
				return
			}
		case "42":
			z.DeviceIdType, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DeviceIdType")
				return
			}
		case "43":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Imei")
				return
			}
			for zb0004 > 0 {
				zb0004--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Imei")
					return
				}
				switch msgp.UnsafeString(field) {
				case "1":
					z.Imei.Value, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Imei", "Value")
						return
					}
				case "2":
					z.Imei.MValue, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Imei", "MValue")
						return
					}
				case "3":
					z.Imei.SValue, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Imei", "SValue")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Imei")
						return
					}
				}
			}
		case "44":
			var zb0005 uint32
			zb0005, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Did")
				return
			}
			for zb0005 > 0 {
				zb0005--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Did")
					return
				}
				switch msgp.UnsafeString(field) {
				case "1":
					z.Did.Value, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Did", "Value")
						return
					}
				case "2":
					z.Did.MValue, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Did", "MValue")
						return
					}
				case "3":
					z.Did.SValue, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Did", "SValue")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Did")
						return
					}
				}
			}
		case "45":
			var zb0006 uint32
			zb0006, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Mac")
				return
			}
			for zb0006 > 0 {
				zb0006--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Mac")
					return
				}
				switch msgp.UnsafeString(field) {
				case "1":
					z.Mac.Value, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Mac", "Value")
						return
					}
				case "2":
					z.Mac.MValue, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Mac", "MValue")
						return
					}
				case "3":
					z.Mac.SValue, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Mac", "SValue")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Mac")
						return
					}
				}
			}
		case "46":
			z.GaId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "GaId")
				return
			}
		case "47":
			z.AppBundleId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AppBundleId")
				return
			}
		case "65":
			z.AppName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AppName")
				return
			}
		case "66":
			z.Ver, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Ver")
				return
			}
		case "67":
			z.Bundle, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bundle")
				return
			}
		case "69":
			var zb0007 uint32
			zb0007, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AppInteractionType")
				return
			}
			if cap(z.AppInteractionType) >= int(zb0007) {
				z.AppInteractionType = (z.AppInteractionType)[:zb0007]
			} else {
				z.AppInteractionType = make([]int, zb0007)
			}
			for za0003 := range z.AppInteractionType {
				z.AppInteractionType[za0003], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "AppInteractionType", za0003)
					return
				}
			}
		case "49":
			var zb0008 uint32
			zb0008, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Deals")
				return
			}
			if cap(z.Deals) >= int(zb0008) {
				z.Deals = (z.Deals)[:zb0008]
			} else {
				z.Deals = make([]Deal, zb0008)
			}
			for za0004 := range z.Deals {
				err = z.Deals[za0004].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Deals", za0004)
					return
				}
			}
		case "50":
			var zb0009 uint32
			zb0009, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ExcludedAdvertisers")
				return
			}
			if cap(z.ExcludedAdvertisers) >= int(zb0009) {
				z.ExcludedAdvertisers = (z.ExcludedAdvertisers)[:zb0009]
			} else {
				z.ExcludedAdvertisers = make([]int, zb0009)
			}
			for za0005 := range z.ExcludedAdvertisers {
				z.ExcludedAdvertisers[za0005], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ExcludedAdvertisers", za0005)
					return
				}
			}
		case "51":
			var zb0010 uint32
			zb0010, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ExcludedList")
				return
			}
			if cap(z.ExcludedList) >= int(zb0010) {
				z.ExcludedList = (z.ExcludedList)[:zb0010]
			} else {
				z.ExcludedList = make([]ExcludeList, zb0010)
			}
			for za0006 := range z.ExcludedList {
				err = z.ExcludedList[za0006].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "ExcludedList", za0006)
					return
				}
			}
		case "52":
			var zb0011 uint32
			zb0011, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "TemplateIds")
				return
			}
			if cap(z.TemplateIds) >= int(zb0011) {
				z.TemplateIds = (z.TemplateIds)[:zb0011]
			} else {
				z.TemplateIds = make([]int, zb0011)
			}
			for za0007 := range z.TemplateIds {
				z.TemplateIds[za0007], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "TemplateIds", za0007)
					return
				}
			}
		case "53":
			z.ClientType, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ClientType")
				return
			}
		case "54":
			z.CountryId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "CountryId")
				return
			}
		case "55":
			z.ProvinceId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ProvinceId")
				return
			}
		case "56":
			z.CityId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "CityId")
				return
			}
		case "58":
			z.SSL, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "SSL")
				return
			}
		case "70":
			var zb0012 uint32
			zb0012, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "PublisherFilterids")
				return
			}
			if cap(z.PublisherFilterids) >= int(zb0012) {
				z.PublisherFilterids = (z.PublisherFilterids)[:zb0012]
			} else {
				z.PublisherFilterids = make([]string, zb0012)
			}
			for za0008 := range z.PublisherFilterids {
				z.PublisherFilterids[za0008], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "PublisherFilterids", za0008)
					return
				}
			}
		case "60":
			var zb0013 uint32
			zb0013, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "BidRule")
				return
			}
			if cap(z.BidRule) >= int(zb0013) {
				z.BidRule = (z.BidRule)[:zb0013]
			} else {
				z.BidRule = make([]BidRuleType, zb0013)
			}
			for za0009 := range z.BidRule {
				var zb0014 uint32
				zb0014, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "BidRule", za0009)
					return
				}
				for zb0014 > 0 {
					zb0014--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "BidRule", za0009)
						return
					}
					switch msgp.UnsafeString(field) {
					case "1":
						z.BidRule[za0009].BidFloor, err = dc.ReadFloat64()
						if err != nil {
							err = msgp.WrapError(err, "BidRule", za0009, "BidFloor")
							return
						}
					case "2":
						var zb0015 uint32
						zb0015, err = dc.ReadArrayHeader()
						if err != nil {
							err = msgp.WrapError(err, "BidRule", za0009, "Category")
							return
						}
						if cap(z.BidRule[za0009].Category) >= int(zb0015) {
							z.BidRule[za0009].Category = (z.BidRule[za0009].Category)[:zb0015]
						} else {
							z.BidRule[za0009].Category = make([]int, zb0015)
						}
						for za0010 := range z.BidRule[za0009].Category {
							z.BidRule[za0009].Category[za0010], err = dc.ReadInt()
							if err != nil {
								err = msgp.WrapError(err, "BidRule", za0009, "Category", za0010)
								return
							}
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "BidRule", za0009)
							return
						}
					}
				}
			}
		case "71":
			z.SysSpotId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SysSpotId")
				return
			}
		case "72":
			var zb0016 uint32
			zb0016, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "CustomSpotIds")
				return
			}
			if cap(z.CustomSpotIds) >= int(zb0016) {
				z.CustomSpotIds = (z.CustomSpotIds)[:zb0016]
			} else {
				z.CustomSpotIds = make([]int, zb0016)
			}
			for za0011 := range z.CustomSpotIds {
				z.CustomSpotIds[za0011], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "CustomSpotIds", za0011)
					return
				}
			}
		case "73":
			z.AdxIdAndAdxSpotId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AdxIdAndAdxSpotId")
				return
			}
		case "74":
			z.AdxReqId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AdxReqId")
				return
			}
		case "75":
			z.AdxImpId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AdxImpId")
				return
			}
		case "76":
			z.ImpId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ImpId")
				return
			}
		case "77":
			z.VisitorId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "VisitorId")
				return
			}
		case "78":
			err = z.UserInfo.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "UserInfo")
				return
			}
		case "90":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Debug")
					return
				}
				z.Debug = nil
			} else {
				if z.Debug == nil {
					z.Debug = new(RequestDebugParam)
				}
				err = z.Debug.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Debug")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *AdapterRequest) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 67
	// write "1"
	err = en.Append(0xde, 0x0, 0x43, 0xa1, 0x31)
	if err != nil {
		return
	}
	err = en.WriteString(z.AdxSpotId)
	if err != nil {
		err = msgp.WrapError(err, "AdxSpotId")
		return
	}
	// write "2"
	err = en.Append(0xa1, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt(z.AdxId)
	if err != nil {
		err = msgp.WrapError(err, "AdxId")
		return
	}
	// write "3"
	err = en.Append(0xa1, 0x33)
	if err != nil {
		return
	}
	err = en.WriteString(z.AdxUID)
	if err != nil {
		err = msgp.WrapError(err, "AdxUID")
		return
	}
	// write "6"
	err = en.Append(0xa1, 0x36)
	if err != nil {
		return
	}
	err = en.WriteString(z.ReqId)
	if err != nil {
		err = msgp.WrapError(err, "ReqId")
		return
	}
	// write "7"
	err = en.Append(0xa1, 0x37)
	if err != nil {
		return
	}
	err = en.WriteString(z.CmUserId)
	if err != nil {
		err = msgp.WrapError(err, "CmUserId")
		return
	}
	// write "8"
	err = en.Append(0xa1, 0x38)
	if err != nil {
		return
	}
	err = en.WriteString(z.Url)
	if err != nil {
		err = msgp.WrapError(err, "Url")
		return
	}
	// write "9"
	err = en.Append(0xa1, 0x39)
	if err != nil {
		return
	}
	err = en.WriteString(z.Referer)
	if err != nil {
		err = msgp.WrapError(err, "Referer")
		return
	}
	// write "64"
	err = en.Append(0xa2, 0x36, 0x34)
	if err != nil {
		return
	}
	err = en.WriteString(z.Search)
	if err != nil {
		err = msgp.WrapError(err, "Search")
		return
	}
	// write "10"
	err = en.Append(0xa2, 0x31, 0x30)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Width)
	if err != nil {
		err = msgp.WrapError(err, "Width")
		return
	}
	// write "11"
	err = en.Append(0xa2, 0x31, 0x31)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Height)
	if err != nil {
		err = msgp.WrapError(err, "Height")
		return
	}
	// write "12"
	err = en.Append(0xa2, 0x31, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SpotSize)
	if err != nil {
		err = msgp.WrapError(err, "SpotSize")
		return
	}
	// write "13"
	err = en.Append(0xa2, 0x31, 0x33)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Minduration)
	if err != nil {
		err = msgp.WrapError(err, "Minduration")
		return
	}
	// write "14"
	err = en.Append(0xa2, 0x31, 0x34)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Maxduration)
	if err != nil {
		err = msgp.WrapError(err, "Maxduration")
		return
	}
	// write "15"
	err = en.Append(0xa2, 0x31, 0x35)
	if err != nil {
		return
	}
	err = en.WriteInt(z.StartDelay)
	if err != nil {
		err = msgp.WrapError(err, "StartDelay")
		return
	}
	// write "62"
	err = en.Append(0xa2, 0x36, 0x32)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Linearity)
	if err != nil {
		err = msgp.WrapError(err, "Linearity")
		return
	}
	// write "63"
	err = en.Append(0xa2, 0x36, 0x33)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Zoom)))
	if err != nil {
		err = msgp.WrapError(err, "Zoom")
		return
	}
	for za0001 := range z.Zoom {
		err = en.WriteString(z.Zoom[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Zoom", za0001)
			return
		}
	}
	// write "16"
	err = en.Append(0xa2, 0x31, 0x36)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Bidfloor)
	if err != nil {
		err = msgp.WrapError(err, "Bidfloor")
		return
	}
	// write "18"
	err = en.Append(0xa2, 0x31, 0x38)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ViewType)
	if err != nil {
		err = msgp.WrapError(err, "ViewType")
		return
	}
	// write "19"
	err = en.Append(0xa2, 0x31, 0x39)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Screen)
	if err != nil {
		err = msgp.WrapError(err, "Screen")
		return
	}
	// write "20"
	err = en.Append(0xa2, 0x32, 0x30)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.CreativeType)))
	if err != nil {
		err = msgp.WrapError(err, "CreativeType")
		return
	}
	for za0002 := range z.CreativeType {
		err = en.WriteInt(z.CreativeType[za0002])
		if err != nil {
			err = msgp.WrapError(err, "CreativeType", za0002)
			return
		}
	}
	// write "21"
	err = en.Append(0xa2, 0x32, 0x31)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MaterialRenderType)
	if err != nil {
		err = msgp.WrapError(err, "MaterialRenderType")
		return
	}
	// write "22"
	err = en.Append(0xa2, 0x32, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Category)
	if err != nil {
		err = msgp.WrapError(err, "Category")
		return
	}
	// write "23"
	err = en.Append(0xa2, 0x32, 0x33)
	if err != nil {
		return
	}
	err = en.WriteString(z.Ua)
	if err != nil {
		err = msgp.WrapError(err, "Ua")
		return
	}
	// write "24"
	err = en.Append(0xa2, 0x32, 0x34)
	if err != nil {
		return
	}
	err = en.WriteString(z.Ip)
	if err != nil {
		err = msgp.WrapError(err, "Ip")
		return
	}
	// write "25"
	err = en.Append(0xa2, 0x32, 0x35)
	if err != nil {
		return
	}
	err = en.WriteString(z.Ipv6)
	if err != nil {
		err = msgp.WrapError(err, "Ipv6")
		return
	}
	// write "26"
	err = en.Append(0xa2, 0x32, 0x36)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.GeoLat)
	if err != nil {
		err = msgp.WrapError(err, "GeoLat")
		return
	}
	// write "27"
	err = en.Append(0xa2, 0x32, 0x37)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.GeoLon)
	if err != nil {
		err = msgp.WrapError(err, "GeoLon")
		return
	}
	// write "28"
	err = en.Append(0xa2, 0x32, 0x38)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Standard)
	if err != nil {
		err = msgp.WrapError(err, "Standard")
		return
	}
	// write "29"
	err = en.Append(0xa2, 0x32, 0x39)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Carrier)
	if err != nil {
		err = msgp.WrapError(err, "Carrier")
		return
	}
	// write "30"
	err = en.Append(0xa2, 0x33, 0x30)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Language)
	if err != nil {
		err = msgp.WrapError(err, "Language")
		return
	}
	// write "31"
	err = en.Append(0xa2, 0x33, 0x31)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Browser)
	if err != nil {
		err = msgp.WrapError(err, "Browser")
		return
	}
	// write "33"
	err = en.Append(0xa2, 0x33, 0x33)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Brand)
	if err != nil {
		err = msgp.WrapError(err, "Brand")
		return
	}
	// write "34"
	err = en.Append(0xa2, 0x33, 0x34)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Model)
	if err != nil {
		err = msgp.WrapError(err, "Model")
		return
	}
	// write "36"
	err = en.Append(0xa2, 0x33, 0x36)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Os)
	if err != nil {
		err = msgp.WrapError(err, "Os")
		return
	}
	// write "37"
	err = en.Append(0xa2, 0x33, 0x37)
	if err != nil {
		return
	}
	err = en.WriteString(z.Osv)
	if err != nil {
		err = msgp.WrapError(err, "Osv")
		return
	}
	// write "40"
	err = en.Append(0xa2, 0x34, 0x30)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Network)
	if err != nil {
		err = msgp.WrapError(err, "Network")
		return
	}
	// write "41"
	err = en.Append(0xa2, 0x34, 0x31)
	if err != nil {
		return
	}
	err = en.WriteInt(z.DeviceType)
	if err != nil {
		err = msgp.WrapError(err, "DeviceType")
		return
	}
	// write "42"
	err = en.Append(0xa2, 0x34, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt(z.DeviceIdType)
	if err != nil {
		err = msgp.WrapError(err, "DeviceIdType")
		return
	}
	// write "43"
	// map header, size 3
	// write "1"
	err = en.Append(0xa2, 0x34, 0x33, 0x83, 0xa1, 0x31)
	if err != nil {
		return
	}
	err = en.WriteString(z.Imei.Value)
	if err != nil {
		err = msgp.WrapError(err, "Imei", "Value")
		return
	}
	// write "2"
	err = en.Append(0xa1, 0x32)
	if err != nil {
		return
	}
	err = en.WriteString(z.Imei.MValue)
	if err != nil {
		err = msgp.WrapError(err, "Imei", "MValue")
		return
	}
	// write "3"
	err = en.Append(0xa1, 0x33)
	if err != nil {
		return
	}
	err = en.WriteString(z.Imei.SValue)
	if err != nil {
		err = msgp.WrapError(err, "Imei", "SValue")
		return
	}
	// write "44"
	// map header, size 3
	// write "1"
	err = en.Append(0xa2, 0x34, 0x34, 0x83, 0xa1, 0x31)
	if err != nil {
		return
	}
	err = en.WriteString(z.Did.Value)
	if err != nil {
		err = msgp.WrapError(err, "Did", "Value")
		return
	}
	// write "2"
	err = en.Append(0xa1, 0x32)
	if err != nil {
		return
	}
	err = en.WriteString(z.Did.MValue)
	if err != nil {
		err = msgp.WrapError(err, "Did", "MValue")
		return
	}
	// write "3"
	err = en.Append(0xa1, 0x33)
	if err != nil {
		return
	}
	err = en.WriteString(z.Did.SValue)
	if err != nil {
		err = msgp.WrapError(err, "Did", "SValue")
		return
	}
	// write "45"
	// map header, size 3
	// write "1"
	err = en.Append(0xa2, 0x34, 0x35, 0x83, 0xa1, 0x31)
	if err != nil {
		return
	}
	err = en.WriteString(z.Mac.Value)
	if err != nil {
		err = msgp.WrapError(err, "Mac", "Value")
		return
	}
	// write "2"
	err = en.Append(0xa1, 0x32)
	if err != nil {
		return
	}
	err = en.WriteString(z.Mac.MValue)
	if err != nil {
		err = msgp.WrapError(err, "Mac", "MValue")
		return
	}
	// write "3"
	err = en.Append(0xa1, 0x33)
	if err != nil {
		return
	}
	err = en.WriteString(z.Mac.SValue)
	if err != nil {
		err = msgp.WrapError(err, "Mac", "SValue")
		return
	}
	// write "46"
	err = en.Append(0xa2, 0x34, 0x36)
	if err != nil {
		return
	}
	err = en.WriteString(z.GaId)
	if err != nil {
		err = msgp.WrapError(err, "GaId")
		return
	}
	// write "47"
	err = en.Append(0xa2, 0x34, 0x37)
	if err != nil {
		return
	}
	err = en.WriteString(z.AppBundleId)
	if err != nil {
		err = msgp.WrapError(err, "AppBundleId")
		return
	}
	// write "65"
	err = en.Append(0xa2, 0x36, 0x35)
	if err != nil {
		return
	}
	err = en.WriteString(z.AppName)
	if err != nil {
		err = msgp.WrapError(err, "AppName")
		return
	}
	// write "66"
	err = en.Append(0xa2, 0x36, 0x36)
	if err != nil {
		return
	}
	err = en.WriteString(z.Ver)
	if err != nil {
		err = msgp.WrapError(err, "Ver")
		return
	}
	// write "67"
	err = en.Append(0xa2, 0x36, 0x37)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bundle)
	if err != nil {
		err = msgp.WrapError(err, "Bundle")
		return
	}
	// write "69"
	err = en.Append(0xa2, 0x36, 0x39)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AppInteractionType)))
	if err != nil {
		err = msgp.WrapError(err, "AppInteractionType")
		return
	}
	for za0003 := range z.AppInteractionType {
		err = en.WriteInt(z.AppInteractionType[za0003])
		if err != nil {
			err = msgp.WrapError(err, "AppInteractionType", za0003)
			return
		}
	}
	// write "49"
	err = en.Append(0xa2, 0x34, 0x39)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Deals)))
	if err != nil {
		err = msgp.WrapError(err, "Deals")
		return
	}
	for za0004 := range z.Deals {
		err = z.Deals[za0004].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Deals", za0004)
			return
		}
	}
	// write "50"
	err = en.Append(0xa2, 0x35, 0x30)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ExcludedAdvertisers)))
	if err != nil {
		err = msgp.WrapError(err, "ExcludedAdvertisers")
		return
	}
	for za0005 := range z.ExcludedAdvertisers {
		err = en.WriteInt(z.ExcludedAdvertisers[za0005])
		if err != nil {
			err = msgp.WrapError(err, "ExcludedAdvertisers", za0005)
			return
		}
	}
	// write "51"
	err = en.Append(0xa2, 0x35, 0x31)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ExcludedList)))
	if err != nil {
		err = msgp.WrapError(err, "ExcludedList")
		return
	}
	for za0006 := range z.ExcludedList {
		err = z.ExcludedList[za0006].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "ExcludedList", za0006)
			return
		}
	}
	// write "52"
	err = en.Append(0xa2, 0x35, 0x32)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.TemplateIds)))
	if err != nil {
		err = msgp.WrapError(err, "TemplateIds")
		return
	}
	for za0007 := range z.TemplateIds {
		err = en.WriteInt(z.TemplateIds[za0007])
		if err != nil {
			err = msgp.WrapError(err, "TemplateIds", za0007)
			return
		}
	}
	// write "53"
	err = en.Append(0xa2, 0x35, 0x33)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ClientType)
	if err != nil {
		err = msgp.WrapError(err, "ClientType")
		return
	}
	// write "54"
	err = en.Append(0xa2, 0x35, 0x34)
	if err != nil {
		return
	}
	err = en.WriteInt(z.CountryId)
	if err != nil {
		err = msgp.WrapError(err, "CountryId")
		return
	}
	// write "55"
	err = en.Append(0xa2, 0x35, 0x35)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ProvinceId)
	if err != nil {
		err = msgp.WrapError(err, "ProvinceId")
		return
	}
	// write "56"
	err = en.Append(0xa2, 0x35, 0x36)
	if err != nil {
		return
	}
	err = en.WriteInt(z.CityId)
	if err != nil {
		err = msgp.WrapError(err, "CityId")
		return
	}
	// write "58"
	err = en.Append(0xa2, 0x35, 0x38)
	if err != nil {
		return
	}
	err = en.WriteBool(z.SSL)
	if err != nil {
		err = msgp.WrapError(err, "SSL")
		return
	}
	// write "70"
	err = en.Append(0xa2, 0x37, 0x30)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.PublisherFilterids)))
	if err != nil {
		err = msgp.WrapError(err, "PublisherFilterids")
		return
	}
	for za0008 := range z.PublisherFilterids {
		err = en.WriteString(z.PublisherFilterids[za0008])
		if err != nil {
			err = msgp.WrapError(err, "PublisherFilterids", za0008)
			return
		}
	}
	// write "60"
	err = en.Append(0xa2, 0x36, 0x30)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.BidRule)))
	if err != nil {
		err = msgp.WrapError(err, "BidRule")
		return
	}
	for za0009 := range z.BidRule {
		// map header, size 2
		// write "1"
		err = en.Append(0x82, 0xa1, 0x31)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.BidRule[za0009].BidFloor)
		if err != nil {
			err = msgp.WrapError(err, "BidRule", za0009, "BidFloor")
			return
		}
		// write "2"
		err = en.Append(0xa1, 0x32)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.BidRule[za0009].Category)))
		if err != nil {
			err = msgp.WrapError(err, "BidRule", za0009, "Category")
			return
		}
		for za0010 := range z.BidRule[za0009].Category {
			err = en.WriteInt(z.BidRule[za0009].Category[za0010])
			if err != nil {
				err = msgp.WrapError(err, "BidRule", za0009, "Category", za0010)
				return
			}
		}
	}
	// write "71"
	err = en.Append(0xa2, 0x37, 0x31)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SysSpotId)
	if err != nil {
		err = msgp.WrapError(err, "SysSpotId")
		return
	}
	// write "72"
	err = en.Append(0xa2, 0x37, 0x32)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.CustomSpotIds)))
	if err != nil {
		err = msgp.WrapError(err, "CustomSpotIds")
		return
	}
	for za0011 := range z.CustomSpotIds {
		err = en.WriteInt(z.CustomSpotIds[za0011])
		if err != nil {
			err = msgp.WrapError(err, "CustomSpotIds", za0011)
			return
		}
	}
	// write "73"
	err = en.Append(0xa2, 0x37, 0x33)
	if err != nil {
		return
	}
	err = en.WriteString(z.AdxIdAndAdxSpotId)
	if err != nil {
		err = msgp.WrapError(err, "AdxIdAndAdxSpotId")
		return
	}
	// write "74"
	err = en.Append(0xa2, 0x37, 0x34)
	if err != nil {
		return
	}
	err = en.WriteString(z.AdxReqId)
	if err != nil {
		err = msgp.WrapError(err, "AdxReqId")
		return
	}
	// write "75"
	err = en.Append(0xa2, 0x37, 0x35)
	if err != nil {
		return
	}
	err = en.WriteString(z.AdxImpId)
	if err != nil {
		err = msgp.WrapError(err, "AdxImpId")
		return
	}
	// write "76"
	err = en.Append(0xa2, 0x37, 0x36)
	if err != nil {
		return
	}
	err = en.WriteString(z.ImpId)
	if err != nil {
		err = msgp.WrapError(err, "ImpId")
		return
	}
	// write "77"
	err = en.Append(0xa2, 0x37, 0x37)
	if err != nil {
		return
	}
	err = en.WriteString(z.VisitorId)
	if err != nil {
		err = msgp.WrapError(err, "VisitorId")
		return
	}
	// write "78"
	err = en.Append(0xa2, 0x37, 0x38)
	if err != nil {
		return
	}
	err = z.UserInfo.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "UserInfo")
		return
	}
	// write "90"
	err = en.Append(0xa2, 0x39, 0x30)
	if err != nil {
		return
	}
	if z.Debug == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Debug.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Debug")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *AdapterRequest) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 67
	// string "1"
	o = append(o, 0xde, 0x0, 0x43, 0xa1, 0x31)
	o = msgp.AppendString(o, z.AdxSpotId)
	// string "2"
	o = append(o, 0xa1, 0x32)
	o = msgp.AppendInt(o, z.AdxId)
	// string "3"
	o = append(o, 0xa1, 0x33)
	o = msgp.AppendString(o, z.AdxUID)
	// string "6"
	o = append(o, 0xa1, 0x36)
	o = msgp.AppendString(o, z.ReqId)
	// string "7"
	o = append(o, 0xa1, 0x37)
	o = msgp.AppendString(o, z.CmUserId)
	// string "8"
	o = append(o, 0xa1, 0x38)
	o = msgp.AppendString(o, z.Url)
	// string "9"
	o = append(o, 0xa1, 0x39)
	o = msgp.AppendString(o, z.Referer)
	// string "64"
	o = append(o, 0xa2, 0x36, 0x34)
	o = msgp.AppendString(o, z.Search)
	// string "10"
	o = append(o, 0xa2, 0x31, 0x30)
	o = msgp.AppendInt(o, z.Width)
	// string "11"
	o = append(o, 0xa2, 0x31, 0x31)
	o = msgp.AppendInt(o, z.Height)
	// string "12"
	o = append(o, 0xa2, 0x31, 0x32)
	o = msgp.AppendInt(o, z.SpotSize)
	// string "13"
	o = append(o, 0xa2, 0x31, 0x33)
	o = msgp.AppendInt(o, z.Minduration)
	// string "14"
	o = append(o, 0xa2, 0x31, 0x34)
	o = msgp.AppendInt(o, z.Maxduration)
	// string "15"
	o = append(o, 0xa2, 0x31, 0x35)
	o = msgp.AppendInt(o, z.StartDelay)
	// string "62"
	o = append(o, 0xa2, 0x36, 0x32)
	o = msgp.AppendBool(o, z.Linearity)
	// string "63"
	o = append(o, 0xa2, 0x36, 0x33)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Zoom)))
	for za0001 := range z.Zoom {
		o = msgp.AppendString(o, z.Zoom[za0001])
	}
	// string "16"
	o = append(o, 0xa2, 0x31, 0x36)
	o = msgp.AppendInt64(o, z.Bidfloor)
	// string "18"
	o = append(o, 0xa2, 0x31, 0x38)
	o = msgp.AppendInt(o, z.ViewType)
	// string "19"
	o = append(o, 0xa2, 0x31, 0x39)
	o = msgp.AppendInt(o, z.Screen)
	// string "20"
	o = append(o, 0xa2, 0x32, 0x30)
	o = msgp.AppendArrayHeader(o, uint32(len(z.CreativeType)))
	for za0002 := range z.CreativeType {
		o = msgp.AppendInt(o, z.CreativeType[za0002])
	}
	// string "21"
	o = append(o, 0xa2, 0x32, 0x31)
	o = msgp.AppendInt(o, z.MaterialRenderType)
	// string "22"
	o = append(o, 0xa2, 0x32, 0x32)
	o = msgp.AppendInt(o, z.Category)
	// string "23"
	o = append(o, 0xa2, 0x32, 0x33)
	o = msgp.AppendString(o, z.Ua)
	// string "24"
	o = append(o, 0xa2, 0x32, 0x34)
	o = msgp.AppendString(o, z.Ip)
	// string "25"
	o = append(o, 0xa2, 0x32, 0x35)
	o = msgp.AppendString(o, z.Ipv6)
	// string "26"
	o = append(o, 0xa2, 0x32, 0x36)
	o = msgp.AppendFloat64(o, z.GeoLat)
	// string "27"
	o = append(o, 0xa2, 0x32, 0x37)
	o = msgp.AppendFloat64(o, z.GeoLon)
	// string "28"
	o = append(o, 0xa2, 0x32, 0x38)
	o = msgp.AppendInt(o, z.Standard)
	// string "29"
	o = append(o, 0xa2, 0x32, 0x39)
	o = msgp.AppendInt(o, z.Carrier)
	// string "30"
	o = append(o, 0xa2, 0x33, 0x30)
	o = msgp.AppendInt(o, z.Language)
	// string "31"
	o = append(o, 0xa2, 0x33, 0x31)
	o = msgp.AppendInt(o, z.Browser)
	// string "33"
	o = append(o, 0xa2, 0x33, 0x33)
	o = msgp.AppendInt(o, z.Brand)
	// string "34"
	o = append(o, 0xa2, 0x33, 0x34)
	o = msgp.AppendInt(o, z.Model)
	// string "36"
	o = append(o, 0xa2, 0x33, 0x36)
	o = msgp.AppendInt(o, z.Os)
	// string "37"
	o = append(o, 0xa2, 0x33, 0x37)
	o = msgp.AppendString(o, z.Osv)
	// string "40"
	o = append(o, 0xa2, 0x34, 0x30)
	o = msgp.AppendInt(o, z.Network)
	// string "41"
	o = append(o, 0xa2, 0x34, 0x31)
	o = msgp.AppendInt(o, z.DeviceType)
	// string "42"
	o = append(o, 0xa2, 0x34, 0x32)
	o = msgp.AppendInt(o, z.DeviceIdType)
	// string "43"
	// map header, size 3
	// string "1"
	o = append(o, 0xa2, 0x34, 0x33, 0x83, 0xa1, 0x31)
	o = msgp.AppendString(o, z.Imei.Value)
	// string "2"
	o = append(o, 0xa1, 0x32)
	o = msgp.AppendString(o, z.Imei.MValue)
	// string "3"
	o = append(o, 0xa1, 0x33)
	o = msgp.AppendString(o, z.Imei.SValue)
	// string "44"
	// map header, size 3
	// string "1"
	o = append(o, 0xa2, 0x34, 0x34, 0x83, 0xa1, 0x31)
	o = msgp.AppendString(o, z.Did.Value)
	// string "2"
	o = append(o, 0xa1, 0x32)
	o = msgp.AppendString(o, z.Did.MValue)
	// string "3"
	o = append(o, 0xa1, 0x33)
	o = msgp.AppendString(o, z.Did.SValue)
	// string "45"
	// map header, size 3
	// string "1"
	o = append(o, 0xa2, 0x34, 0x35, 0x83, 0xa1, 0x31)
	o = msgp.AppendString(o, z.Mac.Value)
	// string "2"
	o = append(o, 0xa1, 0x32)
	o = msgp.AppendString(o, z.Mac.MValue)
	// string "3"
	o = append(o, 0xa1, 0x33)
	o = msgp.AppendString(o, z.Mac.SValue)
	// string "46"
	o = append(o, 0xa2, 0x34, 0x36)
	o = msgp.AppendString(o, z.GaId)
	// string "47"
	o = append(o, 0xa2, 0x34, 0x37)
	o = msgp.AppendString(o, z.AppBundleId)
	// string "65"
	o = append(o, 0xa2, 0x36, 0x35)
	o = msgp.AppendString(o, z.AppName)
	// string "66"
	o = append(o, 0xa2, 0x36, 0x36)
	o = msgp.AppendString(o, z.Ver)
	// string "67"
	o = append(o, 0xa2, 0x36, 0x37)
	o = msgp.AppendString(o, z.Bundle)
	// string "69"
	o = append(o, 0xa2, 0x36, 0x39)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AppInteractionType)))
	for za0003 := range z.AppInteractionType {
		o = msgp.AppendInt(o, z.AppInteractionType[za0003])
	}
	// string "49"
	o = append(o, 0xa2, 0x34, 0x39)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Deals)))
	for za0004 := range z.Deals {
		o, err = z.Deals[za0004].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Deals", za0004)
			return
		}
	}
	// string "50"
	o = append(o, 0xa2, 0x35, 0x30)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ExcludedAdvertisers)))
	for za0005 := range z.ExcludedAdvertisers {
		o = msgp.AppendInt(o, z.ExcludedAdvertisers[za0005])
	}
	// string "51"
	o = append(o, 0xa2, 0x35, 0x31)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ExcludedList)))
	for za0006 := range z.ExcludedList {
		o, err = z.ExcludedList[za0006].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "ExcludedList", za0006)
			return
		}
	}
	// string "52"
	o = append(o, 0xa2, 0x35, 0x32)
	o = msgp.AppendArrayHeader(o, uint32(len(z.TemplateIds)))
	for za0007 := range z.TemplateIds {
		o = msgp.AppendInt(o, z.TemplateIds[za0007])
	}
	// string "53"
	o = append(o, 0xa2, 0x35, 0x33)
	o = msgp.AppendInt(o, z.ClientType)
	// string "54"
	o = append(o, 0xa2, 0x35, 0x34)
	o = msgp.AppendInt(o, z.CountryId)
	// string "55"
	o = append(o, 0xa2, 0x35, 0x35)
	o = msgp.AppendInt(o, z.ProvinceId)
	// string "56"
	o = append(o, 0xa2, 0x35, 0x36)
	o = msgp.AppendInt(o, z.CityId)
	// string "58"
	o = append(o, 0xa2, 0x35, 0x38)
	o = msgp.AppendBool(o, z.SSL)
	// string "70"
	o = append(o, 0xa2, 0x37, 0x30)
	o = msgp.AppendArrayHeader(o, uint32(len(z.PublisherFilterids)))
	for za0008 := range z.PublisherFilterids {
		o = msgp.AppendString(o, z.PublisherFilterids[za0008])
	}
	// string "60"
	o = append(o, 0xa2, 0x36, 0x30)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BidRule)))
	for za0009 := range z.BidRule {
		// map header, size 2
		// string "1"
		o = append(o, 0x82, 0xa1, 0x31)
		o = msgp.AppendFloat64(o, z.BidRule[za0009].BidFloor)
		// string "2"
		o = append(o, 0xa1, 0x32)
		o = msgp.AppendArrayHeader(o, uint32(len(z.BidRule[za0009].Category)))
		for za0010 := range z.BidRule[za0009].Category {
			o = msgp.AppendInt(o, z.BidRule[za0009].Category[za0010])
		}
	}
	// string "71"
	o = append(o, 0xa2, 0x37, 0x31)
	o = msgp.AppendInt(o, z.SysSpotId)
	// string "72"
	o = append(o, 0xa2, 0x37, 0x32)
	o = msgp.AppendArrayHeader(o, uint32(len(z.CustomSpotIds)))
	for za0011 := range z.CustomSpotIds {
		o = msgp.AppendInt(o, z.CustomSpotIds[za0011])
	}
	// string "73"
	o = append(o, 0xa2, 0x37, 0x33)
	o = msgp.AppendString(o, z.AdxIdAndAdxSpotId)
	// string "74"
	o = append(o, 0xa2, 0x37, 0x34)
	o = msgp.AppendString(o, z.AdxReqId)
	// string "75"
	o = append(o, 0xa2, 0x37, 0x35)
	o = msgp.AppendString(o, z.AdxImpId)
	// string "76"
	o = append(o, 0xa2, 0x37, 0x36)
	o = msgp.AppendString(o, z.ImpId)
	// string "77"
	o = append(o, 0xa2, 0x37, 0x37)
	o = msgp.AppendString(o, z.VisitorId)
	// string "78"
	o = append(o, 0xa2, 0x37, 0x38)
	o, err = z.UserInfo.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "UserInfo")
		return
	}
	// string "90"
	o = append(o, 0xa2, 0x39, 0x30)
	if z.Debug == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Debug.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Debug")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AdapterRequest) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			z.AdxSpotId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AdxSpotId")
				return
			}
		case "2":
			z.AdxId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AdxId")
				return
			}
		case "3":
			z.AdxUID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AdxUID")
				return
			}
		case "6":
			z.ReqId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReqId")
				return
			}
		case "7":
			z.CmUserId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CmUserId")
				return
			}
		case "8":
			z.Url, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Url")
				return
			}
		case "9":
			z.Referer, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Referer")
				return
			}
		case "64":
			z.Search, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Search")
				return
			}
		case "10":
			z.Width, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Width")
				return
			}
		case "11":
			z.Height, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Height")
				return
			}
		case "12":
			z.SpotSize, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SpotSize")
				return
			}
		case "13":
			z.Minduration, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Minduration")
				return
			}
		case "14":
			z.Maxduration, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Maxduration")
				return
			}
		case "15":
			z.StartDelay, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartDelay")
				return
			}
		case "62":
			z.Linearity, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Linearity")
				return
			}
		case "63":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Zoom")
				return
			}
			if cap(z.Zoom) >= int(zb0002) {
				z.Zoom = (z.Zoom)[:zb0002]
			} else {
				z.Zoom = make([]string, zb0002)
			}
			for za0001 := range z.Zoom {
				z.Zoom[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Zoom", za0001)
					return
				}
			}
		case "16":
			z.Bidfloor, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bidfloor")
				return
			}
		case "18":
			z.ViewType, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ViewType")
				return
			}
		case "19":
			z.Screen, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Screen")
				return
			}
		case "20":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CreativeType")
				return
			}
			if cap(z.CreativeType) >= int(zb0003) {
				z.CreativeType = (z.CreativeType)[:zb0003]
			} else {
				z.CreativeType = make([]int, zb0003)
			}
			for za0002 := range z.CreativeType {
				z.CreativeType[za0002], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CreativeType", za0002)
					return
				}
			}
		case "21":
			z.MaterialRenderType, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaterialRenderType")
				return
			}
		case "22":
			z.Category, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Category")
				return
			}
		case "23":
			z.Ua, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Ua")
				return
			}
		case "24":
			z.Ip, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Ip")
				return
			}
		case "25":
			z.Ipv6, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Ipv6")
				return
			}
		case "26":
			z.GeoLat, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GeoLat")
				return
			}
		case "27":
			z.GeoLon, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GeoLon")
				return
			}
		case "28":
			z.Standard, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Standard")
				return
			}
		case "29":
			z.Carrier, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Carrier")
				return
			}
		case "30":
			z.Language, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Language")
				return
			}
		case "31":
			z.Browser, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Browser")
				return
			}
		case "33":
			z.Brand, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Brand")
				return
			}
		case "34":
			z.Model, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Model")
				return
			}
		case "36":
			z.Os, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Os")
				return
			}
		case "37":
			z.Osv, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Osv")
				return
			}
		case "40":
			z.Network, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Network")
				return
			}
		case "41":
			z.DeviceType, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeviceType")
				return
			}
		case "42":
			z.DeviceIdType, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeviceIdType")
				return
			}
		case "43":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Imei")
				return
			}
			for zb0004 > 0 {
				zb0004--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Imei")
					return
				}
				switch msgp.UnsafeString(field) {
				case "1":
					z.Imei.Value, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Imei", "Value")
						return
					}
				case "2":
					z.Imei.MValue, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Imei", "MValue")
						return
					}
				case "3":
					z.Imei.SValue, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Imei", "SValue")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Imei")
						return
					}
				}
			}
		case "44":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Did")
				return
			}
			for zb0005 > 0 {
				zb0005--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Did")
					return
				}
				switch msgp.UnsafeString(field) {
				case "1":
					z.Did.Value, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Did", "Value")
						return
					}
				case "2":
					z.Did.MValue, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Did", "MValue")
						return
					}
				case "3":
					z.Did.SValue, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Did", "SValue")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Did")
						return
					}
				}
			}
		case "45":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mac")
				return
			}
			for zb0006 > 0 {
				zb0006--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Mac")
					return
				}
				switch msgp.UnsafeString(field) {
				case "1":
					z.Mac.Value, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Mac", "Value")
						return
					}
				case "2":
					z.Mac.MValue, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Mac", "MValue")
						return
					}
				case "3":
					z.Mac.SValue, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Mac", "SValue")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Mac")
						return
					}
				}
			}
		case "46":
			z.GaId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GaId")
				return
			}
		case "47":
			z.AppBundleId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AppBundleId")
				return
			}
		case "65":
			z.AppName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AppName")
				return
			}
		case "66":
			z.Ver, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Ver")
				return
			}
		case "67":
			z.Bundle, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bundle")
				return
			}
		case "69":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AppInteractionType")
				return
			}
			if cap(z.AppInteractionType) >= int(zb0007) {
				z.AppInteractionType = (z.AppInteractionType)[:zb0007]
			} else {
				z.AppInteractionType = make([]int, zb0007)
			}
			for za0003 := range z.AppInteractionType {
				z.AppInteractionType[za0003], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AppInteractionType", za0003)
					return
				}
			}
		case "49":
			var zb0008 uint32
			zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Deals")
				return
			}
			if cap(z.Deals) >= int(zb0008) {
				z.Deals = (z.Deals)[:zb0008]
			} else {
				z.Deals = make([]Deal, zb0008)
			}
			for za0004 := range z.Deals {
				bts, err = z.Deals[za0004].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Deals", za0004)
					return
				}
			}
		case "50":
			var zb0009 uint32
			zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExcludedAdvertisers")
				return
			}
			if cap(z.ExcludedAdvertisers) >= int(zb0009) {
				z.ExcludedAdvertisers = (z.ExcludedAdvertisers)[:zb0009]
			} else {
				z.ExcludedAdvertisers = make([]int, zb0009)
			}
			for za0005 := range z.ExcludedAdvertisers {
				z.ExcludedAdvertisers[za0005], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExcludedAdvertisers", za0005)
					return
				}
			}
		case "51":
			var zb0010 uint32
			zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExcludedList")
				return
			}
			if cap(z.ExcludedList) >= int(zb0010) {
				z.ExcludedList = (z.ExcludedList)[:zb0010]
			} else {
				z.ExcludedList = make([]ExcludeList, zb0010)
			}
			for za0006 := range z.ExcludedList {
				bts, err = z.ExcludedList[za0006].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExcludedList", za0006)
					return
				}
			}
		case "52":
			var zb0011 uint32
			zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TemplateIds")
				return
			}
			if cap(z.TemplateIds) >= int(zb0011) {
				z.TemplateIds = (z.TemplateIds)[:zb0011]
			} else {
				z.TemplateIds = make([]int, zb0011)
			}
			for za0007 := range z.TemplateIds {
				z.TemplateIds[za0007], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TemplateIds", za0007)
					return
				}
			}
		case "53":
			z.ClientType, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientType")
				return
			}
		case "54":
			z.CountryId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CountryId")
				return
			}
		case "55":
			z.ProvinceId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProvinceId")
				return
			}
		case "56":
			z.CityId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CityId")
				return
			}
		case "58":
			z.SSL, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SSL")
				return
			}
		case "70":
			var zb0012 uint32
			zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PublisherFilterids")
				return
			}
			if cap(z.PublisherFilterids) >= int(zb0012) {
				z.PublisherFilterids = (z.PublisherFilterids)[:zb0012]
			} else {
				z.PublisherFilterids = make([]string, zb0012)
			}
			for za0008 := range z.PublisherFilterids {
				z.PublisherFilterids[za0008], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PublisherFilterids", za0008)
					return
				}
			}
		case "60":
			var zb0013 uint32
			zb0013, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BidRule")
				return
			}
			if cap(z.BidRule) >= int(zb0013) {
				z.BidRule = (z.BidRule)[:zb0013]
			} else {
				z.BidRule = make([]BidRuleType, zb0013)
			}
			for za0009 := range z.BidRule {
				var zb0014 uint32
				zb0014, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BidRule", za0009)
					return
				}
				for zb0014 > 0 {
					zb0014--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "BidRule", za0009)
						return
					}
					switch msgp.UnsafeString(field) {
					case "1":
						z.BidRule[za0009].BidFloor, bts, err = msgp.ReadFloat64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "BidRule", za0009, "BidFloor")
							return
						}
					case "2":
						var zb0015 uint32
						zb0015, bts, err = msgp.ReadArrayHeaderBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "BidRule", za0009, "Category")
							return
						}
						if cap(z.BidRule[za0009].Category) >= int(zb0015) {
							z.BidRule[za0009].Category = (z.BidRule[za0009].Category)[:zb0015]
						} else {
							z.BidRule[za0009].Category = make([]int, zb0015)
						}
						for za0010 := range z.BidRule[za0009].Category {
							z.BidRule[za0009].Category[za0010], bts, err = msgp.ReadIntBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "BidRule", za0009, "Category", za0010)
								return
							}
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "BidRule", za0009)
							return
						}
					}
				}
			}
		case "71":
			z.SysSpotId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SysSpotId")
				return
			}
		case "72":
			var zb0016 uint32
			zb0016, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CustomSpotIds")
				return
			}
			if cap(z.CustomSpotIds) >= int(zb0016) {
				z.CustomSpotIds = (z.CustomSpotIds)[:zb0016]
			} else {
				z.CustomSpotIds = make([]int, zb0016)
			}
			for za0011 := range z.CustomSpotIds {
				z.CustomSpotIds[za0011], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CustomSpotIds", za0011)
					return
				}
			}
		case "73":
			z.AdxIdAndAdxSpotId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AdxIdAndAdxSpotId")
				return
			}
		case "74":
			z.AdxReqId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AdxReqId")
				return
			}
		case "75":
			z.AdxImpId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AdxImpId")
				return
			}
		case "76":
			z.ImpId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ImpId")
				return
			}
		case "77":
			z.VisitorId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "VisitorId")
				return
			}
		case "78":
			bts, err = z.UserInfo.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserInfo")
				return
			}
		case "90":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Debug = nil
			} else {
				if z.Debug == nil {
					z.Debug = new(RequestDebugParam)
				}
				bts, err = z.Debug.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Debug")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AdapterRequest) Msgsize() (s int) {
	s = 3 + 2 + msgp.StringPrefixSize + len(z.AdxSpotId) + 2 + msgp.IntSize + 2 + msgp.StringPrefixSize + len(z.AdxUID) + 2 + msgp.StringPrefixSize + len(z.ReqId) + 2 + msgp.StringPrefixSize + len(z.CmUserId) + 2 + msgp.StringPrefixSize + len(z.Url) + 2 + msgp.StringPrefixSize + len(z.Referer) + 3 + msgp.StringPrefixSize + len(z.Search) + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.BoolSize + 3 + msgp.ArrayHeaderSize
	for za0001 := range z.Zoom {
		s += msgp.StringPrefixSize + len(z.Zoom[za0001])
	}
	s += 3 + msgp.Int64Size + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.ArrayHeaderSize + (len(z.CreativeType) * (msgp.IntSize)) + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.StringPrefixSize + len(z.Ua) + 3 + msgp.StringPrefixSize + len(z.Ip) + 3 + msgp.StringPrefixSize + len(z.Ipv6) + 3 + msgp.Float64Size + 3 + msgp.Float64Size + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.StringPrefixSize + len(z.Osv) + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + 1 + 2 + msgp.StringPrefixSize + len(z.Imei.Value) + 2 + msgp.StringPrefixSize + len(z.Imei.MValue) + 2 + msgp.StringPrefixSize + len(z.Imei.SValue) + 3 + 1 + 2 + msgp.StringPrefixSize + len(z.Did.Value) + 2 + msgp.StringPrefixSize + len(z.Did.MValue) + 2 + msgp.StringPrefixSize + len(z.Did.SValue) + 3 + 1 + 2 + msgp.StringPrefixSize + len(z.Mac.Value) + 2 + msgp.StringPrefixSize + len(z.Mac.MValue) + 2 + msgp.StringPrefixSize + len(z.Mac.SValue) + 3 + msgp.StringPrefixSize + len(z.GaId) + 3 + msgp.StringPrefixSize + len(z.AppBundleId) + 3 + msgp.StringPrefixSize + len(z.AppName) + 3 + msgp.StringPrefixSize + len(z.Ver) + 3 + msgp.StringPrefixSize + len(z.Bundle) + 3 + msgp.ArrayHeaderSize + (len(z.AppInteractionType) * (msgp.IntSize)) + 3 + msgp.ArrayHeaderSize
	for za0004 := range z.Deals {
		s += z.Deals[za0004].Msgsize()
	}
	s += 3 + msgp.ArrayHeaderSize + (len(z.ExcludedAdvertisers) * (msgp.IntSize)) + 3 + msgp.ArrayHeaderSize
	for za0006 := range z.ExcludedList {
		s += z.ExcludedList[za0006].Msgsize()
	}
	s += 3 + msgp.ArrayHeaderSize + (len(z.TemplateIds) * (msgp.IntSize)) + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.BoolSize + 3 + msgp.ArrayHeaderSize
	for za0008 := range z.PublisherFilterids {
		s += msgp.StringPrefixSize + len(z.PublisherFilterids[za0008])
	}
	s += 3 + msgp.ArrayHeaderSize
	for za0009 := range z.BidRule {
		s += 1 + 2 + msgp.Float64Size + 2 + msgp.ArrayHeaderSize + (len(z.BidRule[za0009].Category) * (msgp.IntSize))
	}
	s += 3 + msgp.IntSize + 3 + msgp.ArrayHeaderSize + (len(z.CustomSpotIds) * (msgp.IntSize)) + 3 + msgp.StringPrefixSize + len(z.AdxIdAndAdxSpotId) + 3 + msgp.StringPrefixSize + len(z.AdxReqId) + 3 + msgp.StringPrefixSize + len(z.AdxImpId) + 3 + msgp.StringPrefixSize + len(z.ImpId) + 3 + msgp.StringPrefixSize + len(z.VisitorId) + 3 + z.UserInfo.Msgsize() + 3
	if z.Debug == nil {
		s += msgp.NilSize
	} else {
		s += z.Debug.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BidResponse) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "0":
			z.Code, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Code")
				return
			}
		case "1":
			z.PlanId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "PlanId")
				return
			}
		case "2":
			z.CampaignId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "CampaignId")
				return
			}
		case "4":
			z.CreativeId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "CreativeId")
				return
			}
		case "5":
			z.WhiskyId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "WhiskyId")
				return
			}
		case "7":
			z.DspUserId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DspUserId")
				return
			}
		case "8":
			z.Cost, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Cost")
				return
			}
		case "10":
			z.QualificationId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "QualificationId")
				return
			}
		case "11":
			z.ImpressionId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ImpressionId")
				return
			}
		case "13":
			z.AlgoVersion, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "AlgoVersion")
				return
			}
		case "14":
			z.SpotId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SpotId")
				return
			}
		case "15":
			z.OfferType, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "OfferType")
				return
			}
		case "16":
			z.BudgetId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "BudgetId")
				return
			}
		case "17":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Debug")
					return
				}
				z.Debug = nil
			} else {
				if z.Debug == nil {
					z.Debug = new(ResponseDebugParam)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Debug")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Debug")
						return
					}
					switch msgp.UnsafeString(field) {
					case "1":
						z.Debug.Panic, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Debug", "Panic")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Debug")
							return
						}
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BidResponse) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 14
	// write "0"
	err = en.Append(0x8e, 0xa1, 0x30)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Code)
	if err != nil {
		err = msgp.WrapError(err, "Code")
		return
	}
	// write "1"
	err = en.Append(0xa1, 0x31)
	if err != nil {
		return
	}
	err = en.WriteInt(z.PlanId)
	if err != nil {
		err = msgp.WrapError(err, "PlanId")
		return
	}
	// write "2"
	err = en.Append(0xa1, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt(z.CampaignId)
	if err != nil {
		err = msgp.WrapError(err, "CampaignId")
		return
	}
	// write "4"
	err = en.Append(0xa1, 0x34)
	if err != nil {
		return
	}
	err = en.WriteInt(z.CreativeId)
	if err != nil {
		err = msgp.WrapError(err, "CreativeId")
		return
	}
	// write "5"
	err = en.Append(0xa1, 0x35)
	if err != nil {
		return
	}
	err = en.WriteInt(z.WhiskyId)
	if err != nil {
		err = msgp.WrapError(err, "WhiskyId")
		return
	}
	// write "7"
	err = en.Append(0xa1, 0x37)
	if err != nil {
		return
	}
	err = en.WriteInt(z.DspUserId)
	if err != nil {
		err = msgp.WrapError(err, "DspUserId")
		return
	}
	// write "8"
	err = en.Append(0xa1, 0x38)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Cost)
	if err != nil {
		err = msgp.WrapError(err, "Cost")
		return
	}
	// write "10"
	err = en.Append(0xa2, 0x31, 0x30)
	if err != nil {
		return
	}
	err = en.WriteInt(z.QualificationId)
	if err != nil {
		err = msgp.WrapError(err, "QualificationId")
		return
	}
	// write "11"
	err = en.Append(0xa2, 0x31, 0x31)
	if err != nil {
		return
	}
	err = en.WriteString(z.ImpressionId)
	if err != nil {
		err = msgp.WrapError(err, "ImpressionId")
		return
	}
	// write "13"
	err = en.Append(0xa2, 0x31, 0x33)
	if err != nil {
		return
	}
	err = en.WriteInt(z.AlgoVersion)
	if err != nil {
		err = msgp.WrapError(err, "AlgoVersion")
		return
	}
	// write "14"
	err = en.Append(0xa2, 0x31, 0x34)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SpotId)
	if err != nil {
		err = msgp.WrapError(err, "SpotId")
		return
	}
	// write "15"
	err = en.Append(0xa2, 0x31, 0x35)
	if err != nil {
		return
	}
	err = en.WriteInt(z.OfferType)
	if err != nil {
		err = msgp.WrapError(err, "OfferType")
		return
	}
	// write "16"
	err = en.Append(0xa2, 0x31, 0x36)
	if err != nil {
		return
	}
	err = en.WriteInt(z.BudgetId)
	if err != nil {
		err = msgp.WrapError(err, "BudgetId")
		return
	}
	// write "17"
	err = en.Append(0xa2, 0x31, 0x37)
	if err != nil {
		return
	}
	if z.Debug == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 1
		// write "1"
		err = en.Append(0x81, 0xa1, 0x31)
		if err != nil {
			return
		}
		err = en.WriteString(z.Debug.Panic)
		if err != nil {
			err = msgp.WrapError(err, "Debug", "Panic")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BidResponse) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 14
	// string "0"
	o = append(o, 0x8e, 0xa1, 0x30)
	o = msgp.AppendInt(o, z.Code)
	// string "1"
	o = append(o, 0xa1, 0x31)
	o = msgp.AppendInt(o, z.PlanId)
	// string "2"
	o = append(o, 0xa1, 0x32)
	o = msgp.AppendInt(o, z.CampaignId)
	// string "4"
	o = append(o, 0xa1, 0x34)
	o = msgp.AppendInt(o, z.CreativeId)
	// string "5"
	o = append(o, 0xa1, 0x35)
	o = msgp.AppendInt(o, z.WhiskyId)
	// string "7"
	o = append(o, 0xa1, 0x37)
	o = msgp.AppendInt(o, z.DspUserId)
	// string "8"
	o = append(o, 0xa1, 0x38)
	o = msgp.AppendInt64(o, z.Cost)
	// string "10"
	o = append(o, 0xa2, 0x31, 0x30)
	o = msgp.AppendInt(o, z.QualificationId)
	// string "11"
	o = append(o, 0xa2, 0x31, 0x31)
	o = msgp.AppendString(o, z.ImpressionId)
	// string "13"
	o = append(o, 0xa2, 0x31, 0x33)
	o = msgp.AppendInt(o, z.AlgoVersion)
	// string "14"
	o = append(o, 0xa2, 0x31, 0x34)
	o = msgp.AppendInt(o, z.SpotId)
	// string "15"
	o = append(o, 0xa2, 0x31, 0x35)
	o = msgp.AppendInt(o, z.OfferType)
	// string "16"
	o = append(o, 0xa2, 0x31, 0x36)
	o = msgp.AppendInt(o, z.BudgetId)
	// string "17"
	o = append(o, 0xa2, 0x31, 0x37)
	if z.Debug == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 1
		// string "1"
		o = append(o, 0x81, 0xa1, 0x31)
		o = msgp.AppendString(o, z.Debug.Panic)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BidResponse) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "0":
			z.Code, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Code")
				return
			}
		case "1":
			z.PlanId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PlanId")
				return
			}
		case "2":
			z.CampaignId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CampaignId")
				return
			}
		case "4":
			z.CreativeId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CreativeId")
				return
			}
		case "5":
			z.WhiskyId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WhiskyId")
				return
			}
		case "7":
			z.DspUserId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DspUserId")
				return
			}
		case "8":
			z.Cost, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Cost")
				return
			}
		case "10":
			z.QualificationId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "QualificationId")
				return
			}
		case "11":
			z.ImpressionId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ImpressionId")
				return
			}
		case "13":
			z.AlgoVersion, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AlgoVersion")
				return
			}
		case "14":
			z.SpotId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SpotId")
				return
			}
		case "15":
			z.OfferType, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OfferType")
				return
			}
		case "16":
			z.BudgetId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BudgetId")
				return
			}
		case "17":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Debug = nil
			} else {
				if z.Debug == nil {
					z.Debug = new(ResponseDebugParam)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Debug")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Debug")
						return
					}
					switch msgp.UnsafeString(field) {
					case "1":
						z.Debug.Panic, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Debug", "Panic")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Debug")
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BidResponse) Msgsize() (s int) {
	s = 1 + 2 + msgp.IntSize + 2 + msgp.IntSize + 2 + msgp.IntSize + 2 + msgp.IntSize + 2 + msgp.IntSize + 2 + msgp.IntSize + 2 + msgp.Int64Size + 3 + msgp.IntSize + 3 + msgp.StringPrefixSize + len(z.ImpressionId) + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.IntSize + 3
	if z.Debug == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.StringPrefixSize + len(z.Debug.Panic)
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BidRuleType) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			z.BidFloor, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "BidFloor")
				return
			}
		case "2":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Category")
				return
			}
			if cap(z.Category) >= int(zb0002) {
				z.Category = (z.Category)[:zb0002]
			} else {
				z.Category = make([]int, zb0002)
			}
			for za0001 := range z.Category {
				z.Category[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Category", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BidRuleType) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "1"
	err = en.Append(0x82, 0xa1, 0x31)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.BidFloor)
	if err != nil {
		err = msgp.WrapError(err, "BidFloor")
		return
	}
	// write "2"
	err = en.Append(0xa1, 0x32)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Category)))
	if err != nil {
		err = msgp.WrapError(err, "Category")
		return
	}
	for za0001 := range z.Category {
		err = en.WriteInt(z.Category[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Category", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BidRuleType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "1"
	o = append(o, 0x82, 0xa1, 0x31)
	o = msgp.AppendFloat64(o, z.BidFloor)
	// string "2"
	o = append(o, 0xa1, 0x32)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Category)))
	for za0001 := range z.Category {
		o = msgp.AppendInt(o, z.Category[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BidRuleType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			z.BidFloor, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BidFloor")
				return
			}
		case "2":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Category")
				return
			}
			if cap(z.Category) >= int(zb0002) {
				z.Category = (z.Category)[:zb0002]
			} else {
				z.Category = make([]int, zb0002)
			}
			for za0001 := range z.Category {
				z.Category[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Category", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BidRuleType) Msgsize() (s int) {
	s = 1 + 2 + msgp.Float64Size + 2 + msgp.ArrayHeaderSize + (len(z.Category) * (msgp.IntSize))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BuyerRule) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AdvertiserIds")
				return
			}
			if cap(z.AdvertiserIds) >= int(zb0002) {
				z.AdvertiserIds = (z.AdvertiserIds)[:zb0002]
			} else {
				z.AdvertiserIds = make([]int, zb0002)
			}
			for za0001 := range z.AdvertiserIds {
				z.AdvertiserIds[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "AdvertiserIds", za0001)
					return
				}
			}
		case "2":
			z.MinCpmPrice, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MinCpmPrice")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BuyerRule) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "1"
	err = en.Append(0x82, 0xa1, 0x31)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AdvertiserIds)))
	if err != nil {
		err = msgp.WrapError(err, "AdvertiserIds")
		return
	}
	for za0001 := range z.AdvertiserIds {
		err = en.WriteInt(z.AdvertiserIds[za0001])
		if err != nil {
			err = msgp.WrapError(err, "AdvertiserIds", za0001)
			return
		}
	}
	// write "2"
	err = en.Append(0xa1, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MinCpmPrice)
	if err != nil {
		err = msgp.WrapError(err, "MinCpmPrice")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BuyerRule) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "1"
	o = append(o, 0x82, 0xa1, 0x31)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AdvertiserIds)))
	for za0001 := range z.AdvertiserIds {
		o = msgp.AppendInt(o, z.AdvertiserIds[za0001])
	}
	// string "2"
	o = append(o, 0xa1, 0x32)
	o = msgp.AppendInt(o, z.MinCpmPrice)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BuyerRule) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AdvertiserIds")
				return
			}
			if cap(z.AdvertiserIds) >= int(zb0002) {
				z.AdvertiserIds = (z.AdvertiserIds)[:zb0002]
			} else {
				z.AdvertiserIds = make([]int, zb0002)
			}
			for za0001 := range z.AdvertiserIds {
				z.AdvertiserIds[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AdvertiserIds", za0001)
					return
				}
			}
		case "2":
			z.MinCpmPrice, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinCpmPrice")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BuyerRule) Msgsize() (s int) {
	s = 1 + 2 + msgp.ArrayHeaderSize + (len(z.AdvertiserIds) * (msgp.IntSize)) + 2 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Deal) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			err = z.PreferredDeal.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "PreferredDeal")
				return
			}
		case "2":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "PrivateAuction")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "PrivateAuction")
					return
				}
				switch msgp.UnsafeString(field) {
				case "1":
					z.PrivateAuction.DealId, err = dc.ReadInt()
					if err != nil {
						err = msgp.WrapError(err, "PrivateAuction", "DealId")
						return
					}
				case "2":
					var zb0003 uint32
					zb0003, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "PrivateAuction", "BuyerRules")
						return
					}
					if cap(z.PrivateAuction.BuyerRules) >= int(zb0003) {
						z.PrivateAuction.BuyerRules = (z.PrivateAuction.BuyerRules)[:zb0003]
					} else {
						z.PrivateAuction.BuyerRules = make([]BuyerRule, zb0003)
					}
					for za0001 := range z.PrivateAuction.BuyerRules {
						var zb0004 uint32
						zb0004, err = dc.ReadMapHeader()
						if err != nil {
							err = msgp.WrapError(err, "PrivateAuction", "BuyerRules", za0001)
							return
						}
						for zb0004 > 0 {
							zb0004--
							field, err = dc.ReadMapKeyPtr()
							if err != nil {
								err = msgp.WrapError(err, "PrivateAuction", "BuyerRules", za0001)
								return
							}
							switch msgp.UnsafeString(field) {
							case "1":
								var zb0005 uint32
								zb0005, err = dc.ReadArrayHeader()
								if err != nil {
									err = msgp.WrapError(err, "PrivateAuction", "BuyerRules", za0001, "AdvertiserIds")
									return
								}
								if cap(z.PrivateAuction.BuyerRules[za0001].AdvertiserIds) >= int(zb0005) {
									z.PrivateAuction.BuyerRules[za0001].AdvertiserIds = (z.PrivateAuction.BuyerRules[za0001].AdvertiserIds)[:zb0005]
								} else {
									z.PrivateAuction.BuyerRules[za0001].AdvertiserIds = make([]int, zb0005)
								}
								for za0002 := range z.PrivateAuction.BuyerRules[za0001].AdvertiserIds {
									z.PrivateAuction.BuyerRules[za0001].AdvertiserIds[za0002], err = dc.ReadInt()
									if err != nil {
										err = msgp.WrapError(err, "PrivateAuction", "BuyerRules", za0001, "AdvertiserIds", za0002)
										return
									}
								}
							case "2":
								z.PrivateAuction.BuyerRules[za0001].MinCpmPrice, err = dc.ReadInt()
								if err != nil {
									err = msgp.WrapError(err, "PrivateAuction", "BuyerRules", za0001, "MinCpmPrice")
									return
								}
							default:
								err = dc.Skip()
								if err != nil {
									err = msgp.WrapError(err, "PrivateAuction", "BuyerRules", za0001)
									return
								}
							}
						}
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "PrivateAuction")
						return
					}
				}
			}
		case "3":
			z.Type, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Deal) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "1"
	err = en.Append(0x83, 0xa1, 0x31)
	if err != nil {
		return
	}
	err = z.PreferredDeal.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "PreferredDeal")
		return
	}
	// write "2"
	// map header, size 2
	// write "1"
	err = en.Append(0xa1, 0x32, 0x82, 0xa1, 0x31)
	if err != nil {
		return
	}
	err = en.WriteInt(z.PrivateAuction.DealId)
	if err != nil {
		err = msgp.WrapError(err, "PrivateAuction", "DealId")
		return
	}
	// write "2"
	err = en.Append(0xa1, 0x32)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.PrivateAuction.BuyerRules)))
	if err != nil {
		err = msgp.WrapError(err, "PrivateAuction", "BuyerRules")
		return
	}
	for za0001 := range z.PrivateAuction.BuyerRules {
		// map header, size 2
		// write "1"
		err = en.Append(0x82, 0xa1, 0x31)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.PrivateAuction.BuyerRules[za0001].AdvertiserIds)))
		if err != nil {
			err = msgp.WrapError(err, "PrivateAuction", "BuyerRules", za0001, "AdvertiserIds")
			return
		}
		for za0002 := range z.PrivateAuction.BuyerRules[za0001].AdvertiserIds {
			err = en.WriteInt(z.PrivateAuction.BuyerRules[za0001].AdvertiserIds[za0002])
			if err != nil {
				err = msgp.WrapError(err, "PrivateAuction", "BuyerRules", za0001, "AdvertiserIds", za0002)
				return
			}
		}
		// write "2"
		err = en.Append(0xa1, 0x32)
		if err != nil {
			return
		}
		err = en.WriteInt(z.PrivateAuction.BuyerRules[za0001].MinCpmPrice)
		if err != nil {
			err = msgp.WrapError(err, "PrivateAuction", "BuyerRules", za0001, "MinCpmPrice")
			return
		}
	}
	// write "3"
	err = en.Append(0xa1, 0x33)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Deal) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "1"
	o = append(o, 0x83, 0xa1, 0x31)
	o, err = z.PreferredDeal.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "PreferredDeal")
		return
	}
	// string "2"
	// map header, size 2
	// string "1"
	o = append(o, 0xa1, 0x32, 0x82, 0xa1, 0x31)
	o = msgp.AppendInt(o, z.PrivateAuction.DealId)
	// string "2"
	o = append(o, 0xa1, 0x32)
	o = msgp.AppendArrayHeader(o, uint32(len(z.PrivateAuction.BuyerRules)))
	for za0001 := range z.PrivateAuction.BuyerRules {
		// map header, size 2
		// string "1"
		o = append(o, 0x82, 0xa1, 0x31)
		o = msgp.AppendArrayHeader(o, uint32(len(z.PrivateAuction.BuyerRules[za0001].AdvertiserIds)))
		for za0002 := range z.PrivateAuction.BuyerRules[za0001].AdvertiserIds {
			o = msgp.AppendInt(o, z.PrivateAuction.BuyerRules[za0001].AdvertiserIds[za0002])
		}
		// string "2"
		o = append(o, 0xa1, 0x32)
		o = msgp.AppendInt(o, z.PrivateAuction.BuyerRules[za0001].MinCpmPrice)
	}
	// string "3"
	o = append(o, 0xa1, 0x33)
	o = msgp.AppendInt(o, z.Type)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Deal) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			bts, err = z.PreferredDeal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "PreferredDeal")
				return
			}
		case "2":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PrivateAuction")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "PrivateAuction")
					return
				}
				switch msgp.UnsafeString(field) {
				case "1":
					z.PrivateAuction.DealId, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PrivateAuction", "DealId")
						return
					}
				case "2":
					var zb0003 uint32
					zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PrivateAuction", "BuyerRules")
						return
					}
					if cap(z.PrivateAuction.BuyerRules) >= int(zb0003) {
						z.PrivateAuction.BuyerRules = (z.PrivateAuction.BuyerRules)[:zb0003]
					} else {
						z.PrivateAuction.BuyerRules = make([]BuyerRule, zb0003)
					}
					for za0001 := range z.PrivateAuction.BuyerRules {
						var zb0004 uint32
						zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "PrivateAuction", "BuyerRules", za0001)
							return
						}
						for zb0004 > 0 {
							zb0004--
							field, bts, err = msgp.ReadMapKeyZC(bts)
							if err != nil {
								err = msgp.WrapError(err, "PrivateAuction", "BuyerRules", za0001)
								return
							}
							switch msgp.UnsafeString(field) {
							case "1":
								var zb0005 uint32
								zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "PrivateAuction", "BuyerRules", za0001, "AdvertiserIds")
									return
								}
								if cap(z.PrivateAuction.BuyerRules[za0001].AdvertiserIds) >= int(zb0005) {
									z.PrivateAuction.BuyerRules[za0001].AdvertiserIds = (z.PrivateAuction.BuyerRules[za0001].AdvertiserIds)[:zb0005]
								} else {
									z.PrivateAuction.BuyerRules[za0001].AdvertiserIds = make([]int, zb0005)
								}
								for za0002 := range z.PrivateAuction.BuyerRules[za0001].AdvertiserIds {
									z.PrivateAuction.BuyerRules[za0001].AdvertiserIds[za0002], bts, err = msgp.ReadIntBytes(bts)
									if err != nil {
										err = msgp.WrapError(err, "PrivateAuction", "BuyerRules", za0001, "AdvertiserIds", za0002)
										return
									}
								}
							case "2":
								z.PrivateAuction.BuyerRules[za0001].MinCpmPrice, bts, err = msgp.ReadIntBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "PrivateAuction", "BuyerRules", za0001, "MinCpmPrice")
									return
								}
							default:
								bts, err = msgp.Skip(bts)
								if err != nil {
									err = msgp.WrapError(err, "PrivateAuction", "BuyerRules", za0001)
									return
								}
							}
						}
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "PrivateAuction")
						return
					}
				}
			}
		case "3":
			z.Type, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Deal) Msgsize() (s int) {
	s = 1 + 2 + z.PreferredDeal.Msgsize() + 2 + 1 + 2 + msgp.IntSize + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.PrivateAuction.BuyerRules {
		s += 1 + 2 + msgp.ArrayHeaderSize + (len(z.PrivateAuction.BuyerRules[za0001].AdvertiserIds) * (msgp.IntSize)) + 2 + msgp.IntSize
	}
	s += 2 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DeviceFingerprint) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			z.Value, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Value")
				return
			}
		case "2":
			z.MValue, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "MValue")
				return
			}
		case "3":
			z.SValue, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SValue")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DeviceFingerprint) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "1"
	err = en.Append(0x83, 0xa1, 0x31)
	if err != nil {
		return
	}
	err = en.WriteString(z.Value)
	if err != nil {
		err = msgp.WrapError(err, "Value")
		return
	}
	// write "2"
	err = en.Append(0xa1, 0x32)
	if err != nil {
		return
	}
	err = en.WriteString(z.MValue)
	if err != nil {
		err = msgp.WrapError(err, "MValue")
		return
	}
	// write "3"
	err = en.Append(0xa1, 0x33)
	if err != nil {
		return
	}
	err = en.WriteString(z.SValue)
	if err != nil {
		err = msgp.WrapError(err, "SValue")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DeviceFingerprint) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "1"
	o = append(o, 0x83, 0xa1, 0x31)
	o = msgp.AppendString(o, z.Value)
	// string "2"
	o = append(o, 0xa1, 0x32)
	o = msgp.AppendString(o, z.MValue)
	// string "3"
	o = append(o, 0xa1, 0x33)
	o = msgp.AppendString(o, z.SValue)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DeviceFingerprint) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			z.Value, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Value")
				return
			}
		case "2":
			z.MValue, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MValue")
				return
			}
		case "3":
			z.SValue, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SValue")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DeviceFingerprint) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.Value) + 2 + msgp.StringPrefixSize + len(z.MValue) + 2 + msgp.StringPrefixSize + len(z.SValue)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ExcludeList) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "CategoryIds")
				return
			}
			if cap(z.CategoryIds) >= int(zb0002) {
				z.CategoryIds = (z.CategoryIds)[:zb0002]
			} else {
				z.CategoryIds = make([]int, zb0002)
			}
			for za0001 := range z.CategoryIds {
				z.CategoryIds[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "CategoryIds", za0001)
					return
				}
			}
		case "2":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "LandingPages")
				return
			}
			if cap(z.LandingPages) >= int(zb0003) {
				z.LandingPages = (z.LandingPages)[:zb0003]
			} else {
				z.LandingPages = make([]string, zb0003)
			}
			for za0002 := range z.LandingPages {
				z.LandingPages[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LandingPages", za0002)
					return
				}
			}
		case "3":
			z.Relationship, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Relationship")
				return
			}
		case "4":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AdxCategory")
				return
			}
			if cap(z.AdxCategory) >= int(zb0004) {
				z.AdxCategory = (z.AdxCategory)[:zb0004]
			} else {
				z.AdxCategory = make([]string, zb0004)
			}
			for za0003 := range z.AdxCategory {
				z.AdxCategory[za0003], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "AdxCategory", za0003)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ExcludeList) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "1"
	err = en.Append(0x84, 0xa1, 0x31)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.CategoryIds)))
	if err != nil {
		err = msgp.WrapError(err, "CategoryIds")
		return
	}
	for za0001 := range z.CategoryIds {
		err = en.WriteInt(z.CategoryIds[za0001])
		if err != nil {
			err = msgp.WrapError(err, "CategoryIds", za0001)
			return
		}
	}
	// write "2"
	err = en.Append(0xa1, 0x32)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.LandingPages)))
	if err != nil {
		err = msgp.WrapError(err, "LandingPages")
		return
	}
	for za0002 := range z.LandingPages {
		err = en.WriteString(z.LandingPages[za0002])
		if err != nil {
			err = msgp.WrapError(err, "LandingPages", za0002)
			return
		}
	}
	// write "3"
	err = en.Append(0xa1, 0x33)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Relationship)
	if err != nil {
		err = msgp.WrapError(err, "Relationship")
		return
	}
	// write "4"
	err = en.Append(0xa1, 0x34)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AdxCategory)))
	if err != nil {
		err = msgp.WrapError(err, "AdxCategory")
		return
	}
	for za0003 := range z.AdxCategory {
		err = en.WriteString(z.AdxCategory[za0003])
		if err != nil {
			err = msgp.WrapError(err, "AdxCategory", za0003)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ExcludeList) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "1"
	o = append(o, 0x84, 0xa1, 0x31)
	o = msgp.AppendArrayHeader(o, uint32(len(z.CategoryIds)))
	for za0001 := range z.CategoryIds {
		o = msgp.AppendInt(o, z.CategoryIds[za0001])
	}
	// string "2"
	o = append(o, 0xa1, 0x32)
	o = msgp.AppendArrayHeader(o, uint32(len(z.LandingPages)))
	for za0002 := range z.LandingPages {
		o = msgp.AppendString(o, z.LandingPages[za0002])
	}
	// string "3"
	o = append(o, 0xa1, 0x33)
	o = msgp.AppendInt(o, z.Relationship)
	// string "4"
	o = append(o, 0xa1, 0x34)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AdxCategory)))
	for za0003 := range z.AdxCategory {
		o = msgp.AppendString(o, z.AdxCategory[za0003])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ExcludeList) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CategoryIds")
				return
			}
			if cap(z.CategoryIds) >= int(zb0002) {
				z.CategoryIds = (z.CategoryIds)[:zb0002]
			} else {
				z.CategoryIds = make([]int, zb0002)
			}
			for za0001 := range z.CategoryIds {
				z.CategoryIds[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CategoryIds", za0001)
					return
				}
			}
		case "2":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LandingPages")
				return
			}
			if cap(z.LandingPages) >= int(zb0003) {
				z.LandingPages = (z.LandingPages)[:zb0003]
			} else {
				z.LandingPages = make([]string, zb0003)
			}
			for za0002 := range z.LandingPages {
				z.LandingPages[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LandingPages", za0002)
					return
				}
			}
		case "3":
			z.Relationship, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Relationship")
				return
			}
		case "4":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AdxCategory")
				return
			}
			if cap(z.AdxCategory) >= int(zb0004) {
				z.AdxCategory = (z.AdxCategory)[:zb0004]
			} else {
				z.AdxCategory = make([]string, zb0004)
			}
			for za0003 := range z.AdxCategory {
				z.AdxCategory[za0003], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AdxCategory", za0003)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ExcludeList) Msgsize() (s int) {
	s = 1 + 2 + msgp.ArrayHeaderSize + (len(z.CategoryIds) * (msgp.IntSize)) + 2 + msgp.ArrayHeaderSize
	for za0002 := range z.LandingPages {
		s += msgp.StringPrefixSize + len(z.LandingPages[za0002])
	}
	s += 2 + msgp.IntSize + 2 + msgp.ArrayHeaderSize
	for za0003 := range z.AdxCategory {
		s += msgp.StringPrefixSize + len(z.AdxCategory[za0003])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MultiBidResponse) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(MultiBidResponse, zb0002)
	}
	for zb0001 := range *z {
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			(*z)[zb0001] = nil
		} else {
			if (*z)[zb0001] == nil {
				(*z)[zb0001] = new(MultiResponse)
			}
			var field []byte
			_ = field
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, zb0001)
					return
				}
				switch msgp.UnsafeString(field) {
				case "SequenceId":
					(*z)[zb0001].SequenceId, err = dc.ReadInt()
					if err != nil {
						err = msgp.WrapError(err, zb0001, "SequenceId")
						return
					}
				case "Response":
					if dc.IsNil() {
						err = dc.ReadNil()
						if err != nil {
							err = msgp.WrapError(err, zb0001, "Response")
							return
						}
						(*z)[zb0001].Response = nil
					} else {
						if (*z)[zb0001].Response == nil {
							(*z)[zb0001].Response = new(BidResponse)
						}
						err = (*z)[zb0001].Response.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, zb0001, "Response")
							return
						}
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, zb0001)
						return
					}
				}
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z MultiBidResponse) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteArrayHeader(uint32(len(z)))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0004 := range z {
		if z[zb0004] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 2
			// write "SequenceId"
			err = en.Append(0x82, 0xaa, 0x53, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x49, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt(z[zb0004].SequenceId)
			if err != nil {
				err = msgp.WrapError(err, zb0004, "SequenceId")
				return
			}
			// write "Response"
			err = en.Append(0xa8, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65)
			if err != nil {
				return
			}
			if z[zb0004].Response == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z[zb0004].Response.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, zb0004, "Response")
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MultiBidResponse) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for zb0004 := range z {
		if z[zb0004] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 2
			// string "SequenceId"
			o = append(o, 0x82, 0xaa, 0x53, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x49, 0x64)
			o = msgp.AppendInt(o, z[zb0004].SequenceId)
			// string "Response"
			o = append(o, 0xa8, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65)
			if z[zb0004].Response == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z[zb0004].Response.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, zb0004, "Response")
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MultiBidResponse) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(MultiBidResponse, zb0002)
	}
	for zb0001 := range *z {
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			(*z)[zb0001] = nil
		} else {
			if (*z)[zb0001] == nil {
				(*z)[zb0001] = new(MultiResponse)
			}
			var field []byte
			_ = field
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, zb0001)
					return
				}
				switch msgp.UnsafeString(field) {
				case "SequenceId":
					(*z)[zb0001].SequenceId, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, zb0001, "SequenceId")
						return
					}
				case "Response":
					if msgp.IsNil(bts) {
						bts, err = msgp.ReadNilBytes(bts)
						if err != nil {
							return
						}
						(*z)[zb0001].Response = nil
					} else {
						if (*z)[zb0001].Response == nil {
							(*z)[zb0001].Response = new(BidResponse)
						}
						bts, err = (*z)[zb0001].Response.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, zb0001, "Response")
							return
						}
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, zb0001)
						return
					}
				}
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MultiBidResponse) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zb0004 := range z {
		if z[zb0004] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 11 + msgp.IntSize + 9
			if z[zb0004].Response == nil {
				s += msgp.NilSize
			} else {
				s += z[zb0004].Response.Msgsize()
			}
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MultiResponse) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "SequenceId":
			z.SequenceId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SequenceId")
				return
			}
		case "Response":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Response")
					return
				}
				z.Response = nil
			} else {
				if z.Response == nil {
					z.Response = new(BidResponse)
				}
				err = z.Response.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Response")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MultiResponse) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "SequenceId"
	err = en.Append(0x82, 0xaa, 0x53, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SequenceId)
	if err != nil {
		err = msgp.WrapError(err, "SequenceId")
		return
	}
	// write "Response"
	err = en.Append(0xa8, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65)
	if err != nil {
		return
	}
	if z.Response == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Response.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Response")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MultiResponse) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "SequenceId"
	o = append(o, 0x82, 0xaa, 0x53, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x49, 0x64)
	o = msgp.AppendInt(o, z.SequenceId)
	// string "Response"
	o = append(o, 0xa8, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65)
	if z.Response == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Response.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Response")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MultiResponse) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "SequenceId":
			z.SequenceId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SequenceId")
				return
			}
		case "Response":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Response = nil
			} else {
				if z.Response == nil {
					z.Response = new(BidResponse)
				}
				bts, err = z.Response.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Response")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MultiResponse) Msgsize() (s int) {
	s = 1 + 11 + msgp.IntSize + 9
	if z.Response == nil {
		s += msgp.NilSize
	} else {
		s += z.Response.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MultipleAdapterRequest) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(MultipleAdapterRequest, zb0002)
	}
	for zb0001 := range *z {
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			(*z)[zb0001] = nil
		} else {
			if (*z)[zb0001] == nil {
				(*z)[zb0001] = new(MultipleAdapterRequestItem)
			}
			var field []byte
			_ = field
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, zb0001)
					return
				}
				switch msgp.UnsafeString(field) {
				case "SequenceId":
					(*z)[zb0001].SequenceId, err = dc.ReadInt()
					if err != nil {
						err = msgp.WrapError(err, zb0001, "SequenceId")
						return
					}
				case "Request":
					if dc.IsNil() {
						err = dc.ReadNil()
						if err != nil {
							err = msgp.WrapError(err, zb0001, "Request")
							return
						}
						(*z)[zb0001].Request = nil
					} else {
						if (*z)[zb0001].Request == nil {
							(*z)[zb0001].Request = new(AdapterRequest)
						}
						err = (*z)[zb0001].Request.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, zb0001, "Request")
							return
						}
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, zb0001)
						return
					}
				}
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z MultipleAdapterRequest) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteArrayHeader(uint32(len(z)))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0004 := range z {
		if z[zb0004] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 2
			// write "SequenceId"
			err = en.Append(0x82, 0xaa, 0x53, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x49, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt(z[zb0004].SequenceId)
			if err != nil {
				err = msgp.WrapError(err, zb0004, "SequenceId")
				return
			}
			// write "Request"
			err = en.Append(0xa7, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74)
			if err != nil {
				return
			}
			if z[zb0004].Request == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z[zb0004].Request.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, zb0004, "Request")
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MultipleAdapterRequest) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for zb0004 := range z {
		if z[zb0004] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 2
			// string "SequenceId"
			o = append(o, 0x82, 0xaa, 0x53, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x49, 0x64)
			o = msgp.AppendInt(o, z[zb0004].SequenceId)
			// string "Request"
			o = append(o, 0xa7, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74)
			if z[zb0004].Request == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z[zb0004].Request.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, zb0004, "Request")
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MultipleAdapterRequest) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(MultipleAdapterRequest, zb0002)
	}
	for zb0001 := range *z {
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			(*z)[zb0001] = nil
		} else {
			if (*z)[zb0001] == nil {
				(*z)[zb0001] = new(MultipleAdapterRequestItem)
			}
			var field []byte
			_ = field
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, zb0001)
					return
				}
				switch msgp.UnsafeString(field) {
				case "SequenceId":
					(*z)[zb0001].SequenceId, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, zb0001, "SequenceId")
						return
					}
				case "Request":
					if msgp.IsNil(bts) {
						bts, err = msgp.ReadNilBytes(bts)
						if err != nil {
							return
						}
						(*z)[zb0001].Request = nil
					} else {
						if (*z)[zb0001].Request == nil {
							(*z)[zb0001].Request = new(AdapterRequest)
						}
						bts, err = (*z)[zb0001].Request.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, zb0001, "Request")
							return
						}
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, zb0001)
						return
					}
				}
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MultipleAdapterRequest) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zb0004 := range z {
		if z[zb0004] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 11 + msgp.IntSize + 8
			if z[zb0004].Request == nil {
				s += msgp.NilSize
			} else {
				s += z[zb0004].Request.Msgsize()
			}
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MultipleAdapterRequestItem) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "SequenceId":
			z.SequenceId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SequenceId")
				return
			}
		case "Request":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Request")
					return
				}
				z.Request = nil
			} else {
				if z.Request == nil {
					z.Request = new(AdapterRequest)
				}
				err = z.Request.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Request")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MultipleAdapterRequestItem) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "SequenceId"
	err = en.Append(0x82, 0xaa, 0x53, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SequenceId)
	if err != nil {
		err = msgp.WrapError(err, "SequenceId")
		return
	}
	// write "Request"
	err = en.Append(0xa7, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74)
	if err != nil {
		return
	}
	if z.Request == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Request.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Request")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MultipleAdapterRequestItem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "SequenceId"
	o = append(o, 0x82, 0xaa, 0x53, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x49, 0x64)
	o = msgp.AppendInt(o, z.SequenceId)
	// string "Request"
	o = append(o, 0xa7, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74)
	if z.Request == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Request.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Request")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MultipleAdapterRequestItem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "SequenceId":
			z.SequenceId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SequenceId")
				return
			}
		case "Request":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Request = nil
			} else {
				if z.Request == nil {
					z.Request = new(AdapterRequest)
				}
				bts, err = z.Request.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Request")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MultipleAdapterRequestItem) Msgsize() (s int) {
	s = 1 + 11 + msgp.IntSize + 8
	if z.Request == nil {
		s += msgp.NilSize
	} else {
		s += z.Request.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PreferredDeal) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			z.DealId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DealId")
				return
			}
		case "2":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AdvertiserIds")
				return
			}
			if cap(z.AdvertiserIds) >= int(zb0002) {
				z.AdvertiserIds = (z.AdvertiserIds)[:zb0002]
			} else {
				z.AdvertiserIds = make([]int, zb0002)
			}
			for za0001 := range z.AdvertiserIds {
				z.AdvertiserIds[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "AdvertiserIds", za0001)
					return
				}
			}
		case "3":
			z.FixedPrice, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "FixedPrice")
				return
			}
		case "4":
			z.FixedPriceUnit, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "FixedPriceUnit")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PreferredDeal) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "1"
	err = en.Append(0x84, 0xa1, 0x31)
	if err != nil {
		return
	}
	err = en.WriteInt(z.DealId)
	if err != nil {
		err = msgp.WrapError(err, "DealId")
		return
	}
	// write "2"
	err = en.Append(0xa1, 0x32)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AdvertiserIds)))
	if err != nil {
		err = msgp.WrapError(err, "AdvertiserIds")
		return
	}
	for za0001 := range z.AdvertiserIds {
		err = en.WriteInt(z.AdvertiserIds[za0001])
		if err != nil {
			err = msgp.WrapError(err, "AdvertiserIds", za0001)
			return
		}
	}
	// write "3"
	err = en.Append(0xa1, 0x33)
	if err != nil {
		return
	}
	err = en.WriteInt(z.FixedPrice)
	if err != nil {
		err = msgp.WrapError(err, "FixedPrice")
		return
	}
	// write "4"
	err = en.Append(0xa1, 0x34)
	if err != nil {
		return
	}
	err = en.WriteInt(z.FixedPriceUnit)
	if err != nil {
		err = msgp.WrapError(err, "FixedPriceUnit")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PreferredDeal) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "1"
	o = append(o, 0x84, 0xa1, 0x31)
	o = msgp.AppendInt(o, z.DealId)
	// string "2"
	o = append(o, 0xa1, 0x32)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AdvertiserIds)))
	for za0001 := range z.AdvertiserIds {
		o = msgp.AppendInt(o, z.AdvertiserIds[za0001])
	}
	// string "3"
	o = append(o, 0xa1, 0x33)
	o = msgp.AppendInt(o, z.FixedPrice)
	// string "4"
	o = append(o, 0xa1, 0x34)
	o = msgp.AppendInt(o, z.FixedPriceUnit)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PreferredDeal) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			z.DealId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DealId")
				return
			}
		case "2":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AdvertiserIds")
				return
			}
			if cap(z.AdvertiserIds) >= int(zb0002) {
				z.AdvertiserIds = (z.AdvertiserIds)[:zb0002]
			} else {
				z.AdvertiserIds = make([]int, zb0002)
			}
			for za0001 := range z.AdvertiserIds {
				z.AdvertiserIds[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AdvertiserIds", za0001)
					return
				}
			}
		case "3":
			z.FixedPrice, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FixedPrice")
				return
			}
		case "4":
			z.FixedPriceUnit, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FixedPriceUnit")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PreferredDeal) Msgsize() (s int) {
	s = 1 + 2 + msgp.IntSize + 2 + msgp.ArrayHeaderSize + (len(z.AdvertiserIds) * (msgp.IntSize)) + 2 + msgp.IntSize + 2 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PrivateAuction) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			z.DealId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DealId")
				return
			}
		case "2":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "BuyerRules")
				return
			}
			if cap(z.BuyerRules) >= int(zb0002) {
				z.BuyerRules = (z.BuyerRules)[:zb0002]
			} else {
				z.BuyerRules = make([]BuyerRule, zb0002)
			}
			for za0001 := range z.BuyerRules {
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "BuyerRules", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "BuyerRules", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "1":
						var zb0004 uint32
						zb0004, err = dc.ReadArrayHeader()
						if err != nil {
							err = msgp.WrapError(err, "BuyerRules", za0001, "AdvertiserIds")
							return
						}
						if cap(z.BuyerRules[za0001].AdvertiserIds) >= int(zb0004) {
							z.BuyerRules[za0001].AdvertiserIds = (z.BuyerRules[za0001].AdvertiserIds)[:zb0004]
						} else {
							z.BuyerRules[za0001].AdvertiserIds = make([]int, zb0004)
						}
						for za0002 := range z.BuyerRules[za0001].AdvertiserIds {
							z.BuyerRules[za0001].AdvertiserIds[za0002], err = dc.ReadInt()
							if err != nil {
								err = msgp.WrapError(err, "BuyerRules", za0001, "AdvertiserIds", za0002)
								return
							}
						}
					case "2":
						z.BuyerRules[za0001].MinCpmPrice, err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "BuyerRules", za0001, "MinCpmPrice")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "BuyerRules", za0001)
							return
						}
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PrivateAuction) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "1"
	err = en.Append(0x82, 0xa1, 0x31)
	if err != nil {
		return
	}
	err = en.WriteInt(z.DealId)
	if err != nil {
		err = msgp.WrapError(err, "DealId")
		return
	}
	// write "2"
	err = en.Append(0xa1, 0x32)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.BuyerRules)))
	if err != nil {
		err = msgp.WrapError(err, "BuyerRules")
		return
	}
	for za0001 := range z.BuyerRules {
		// map header, size 2
		// write "1"
		err = en.Append(0x82, 0xa1, 0x31)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.BuyerRules[za0001].AdvertiserIds)))
		if err != nil {
			err = msgp.WrapError(err, "BuyerRules", za0001, "AdvertiserIds")
			return
		}
		for za0002 := range z.BuyerRules[za0001].AdvertiserIds {
			err = en.WriteInt(z.BuyerRules[za0001].AdvertiserIds[za0002])
			if err != nil {
				err = msgp.WrapError(err, "BuyerRules", za0001, "AdvertiserIds", za0002)
				return
			}
		}
		// write "2"
		err = en.Append(0xa1, 0x32)
		if err != nil {
			return
		}
		err = en.WriteInt(z.BuyerRules[za0001].MinCpmPrice)
		if err != nil {
			err = msgp.WrapError(err, "BuyerRules", za0001, "MinCpmPrice")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PrivateAuction) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "1"
	o = append(o, 0x82, 0xa1, 0x31)
	o = msgp.AppendInt(o, z.DealId)
	// string "2"
	o = append(o, 0xa1, 0x32)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BuyerRules)))
	for za0001 := range z.BuyerRules {
		// map header, size 2
		// string "1"
		o = append(o, 0x82, 0xa1, 0x31)
		o = msgp.AppendArrayHeader(o, uint32(len(z.BuyerRules[za0001].AdvertiserIds)))
		for za0002 := range z.BuyerRules[za0001].AdvertiserIds {
			o = msgp.AppendInt(o, z.BuyerRules[za0001].AdvertiserIds[za0002])
		}
		// string "2"
		o = append(o, 0xa1, 0x32)
		o = msgp.AppendInt(o, z.BuyerRules[za0001].MinCpmPrice)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PrivateAuction) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			z.DealId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DealId")
				return
			}
		case "2":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BuyerRules")
				return
			}
			if cap(z.BuyerRules) >= int(zb0002) {
				z.BuyerRules = (z.BuyerRules)[:zb0002]
			} else {
				z.BuyerRules = make([]BuyerRule, zb0002)
			}
			for za0001 := range z.BuyerRules {
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BuyerRules", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "BuyerRules", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "1":
						var zb0004 uint32
						zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "BuyerRules", za0001, "AdvertiserIds")
							return
						}
						if cap(z.BuyerRules[za0001].AdvertiserIds) >= int(zb0004) {
							z.BuyerRules[za0001].AdvertiserIds = (z.BuyerRules[za0001].AdvertiserIds)[:zb0004]
						} else {
							z.BuyerRules[za0001].AdvertiserIds = make([]int, zb0004)
						}
						for za0002 := range z.BuyerRules[za0001].AdvertiserIds {
							z.BuyerRules[za0001].AdvertiserIds[za0002], bts, err = msgp.ReadIntBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "BuyerRules", za0001, "AdvertiserIds", za0002)
								return
							}
						}
					case "2":
						z.BuyerRules[za0001].MinCpmPrice, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "BuyerRules", za0001, "MinCpmPrice")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "BuyerRules", za0001)
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PrivateAuction) Msgsize() (s int) {
	s = 1 + 2 + msgp.IntSize + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.BuyerRules {
		s += 1 + 2 + msgp.ArrayHeaderSize + (len(z.BuyerRules[za0001].AdvertiserIds) * (msgp.IntSize)) + 2 + msgp.IntSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RequestDebugParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Tags")
				return
			}
			if z.Tags == nil {
				z.Tags = make(map[string]interface{}, zb0002)
			} else if len(z.Tags) > 0 {
				for key := range z.Tags {
					delete(z.Tags, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 interface{}
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Tags")
					return
				}
				za0002, err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Tags", za0001)
					return
				}
				z.Tags[za0001] = za0002
			}
		case "2":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Info")
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Info")
					return
				}
				switch msgp.UnsafeString(field) {
				case "1":
					var zb0004 uint32
					zb0004, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "Info", "CampaignId")
						return
					}
					if cap(z.Info.CampaignId) >= int(zb0004) {
						z.Info.CampaignId = (z.Info.CampaignId)[:zb0004]
					} else {
						z.Info.CampaignId = make([]int, zb0004)
					}
					for za0003 := range z.Info.CampaignId {
						z.Info.CampaignId[za0003], err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "Info", "CampaignId", za0003)
							return
						}
					}
				case "2":
					var zb0005 uint32
					zb0005, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "Info", "PlanId")
						return
					}
					if cap(z.Info.PlanId) >= int(zb0005) {
						z.Info.PlanId = (z.Info.PlanId)[:zb0005]
					} else {
						z.Info.PlanId = make([]int, zb0005)
					}
					for za0004 := range z.Info.PlanId {
						z.Info.PlanId[za0004], err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "Info", "PlanId", za0004)
							return
						}
					}
				case "3":
					var zb0006 uint32
					zb0006, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "Info", "CreativeId")
						return
					}
					if cap(z.Info.CreativeId) >= int(zb0006) {
						z.Info.CreativeId = (z.Info.CreativeId)[:zb0006]
					} else {
						z.Info.CreativeId = make([]int, zb0006)
					}
					for za0005 := range z.Info.CreativeId {
						z.Info.CreativeId[za0005], err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "Info", "CreativeId", za0005)
							return
						}
					}
				case "4":
					var zb0007 uint32
					zb0007, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "Info", "WhiskyId")
						return
					}
					if cap(z.Info.WhiskyId) >= int(zb0007) {
						z.Info.WhiskyId = (z.Info.WhiskyId)[:zb0007]
					} else {
						z.Info.WhiskyId = make([]int, zb0007)
					}
					for za0006 := range z.Info.WhiskyId {
						z.Info.WhiskyId[za0006], err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "Info", "WhiskyId", za0006)
							return
						}
					}
				case "5":
					var zb0008 uint32
					zb0008, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "Info", "BudgetId")
						return
					}
					if cap(z.Info.BudgetId) >= int(zb0008) {
						z.Info.BudgetId = (z.Info.BudgetId)[:zb0008]
					} else {
						z.Info.BudgetId = make([]int, zb0008)
					}
					for za0007 := range z.Info.BudgetId {
						z.Info.BudgetId[za0007], err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "Info", "BudgetId", za0007)
							return
						}
					}
				case "6":
					var zb0009 uint32
					zb0009, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "Info", "UserId")
						return
					}
					if cap(z.Info.UserId) >= int(zb0009) {
						z.Info.UserId = (z.Info.UserId)[:zb0009]
					} else {
						z.Info.UserId = make([]int, zb0009)
					}
					for za0008 := range z.Info.UserId {
						z.Info.UserId[za0008], err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "Info", "UserId", za0008)
							return
						}
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Info")
						return
					}
				}
			}
		case "3":
			var zb0010 uint32
			zb0010, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Algorithm")
				return
			}
			for zb0010 > 0 {
				zb0010--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Algorithm")
					return
				}
				switch msgp.UnsafeString(field) {
				case "1":
					z.Algorithm.Version, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Algorithm", "Version")
						return
					}
				case "2":
					z.Algorithm.GovernorOFF, err = dc.ReadBool()
					if err != nil {
						err = msgp.WrapError(err, "Algorithm", "GovernorOFF")
						return
					}
				case "3":
					z.Algorithm.StatRateOFF, err = dc.ReadBool()
					if err != nil {
						err = msgp.WrapError(err, "Algorithm", "StatRateOFF")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Algorithm")
						return
					}
				}
			}
		case "4":
			var zb0011 uint32
			zb0011, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Runtime")
				return
			}
			for zb0011 > 0 {
				zb0011--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Runtime")
					return
				}
				switch msgp.UnsafeString(field) {
				case "1":
					z.Runtime.PanicON, err = dc.ReadBool()
					if err != nil {
						err = msgp.WrapError(err, "Runtime", "PanicON")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Runtime")
						return
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RequestDebugParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "1"
	err = en.Append(0x84, 0xa1, 0x31)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Tags)))
	if err != nil {
		err = msgp.WrapError(err, "Tags")
		return
	}
	for za0001, za0002 := range z.Tags {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "Tags")
			return
		}
		err = en.WriteIntf(za0002)
		if err != nil {
			err = msgp.WrapError(err, "Tags", za0001)
			return
		}
	}
	// write "2"
	// map header, size 6
	// write "1"
	err = en.Append(0xa1, 0x32, 0x86, 0xa1, 0x31)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Info.CampaignId)))
	if err != nil {
		err = msgp.WrapError(err, "Info", "CampaignId")
		return
	}
	for za0003 := range z.Info.CampaignId {
		err = en.WriteInt(z.Info.CampaignId[za0003])
		if err != nil {
			err = msgp.WrapError(err, "Info", "CampaignId", za0003)
			return
		}
	}
	// write "2"
	err = en.Append(0xa1, 0x32)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Info.PlanId)))
	if err != nil {
		err = msgp.WrapError(err, "Info", "PlanId")
		return
	}
	for za0004 := range z.Info.PlanId {
		err = en.WriteInt(z.Info.PlanId[za0004])
		if err != nil {
			err = msgp.WrapError(err, "Info", "PlanId", za0004)
			return
		}
	}
	// write "3"
	err = en.Append(0xa1, 0x33)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Info.CreativeId)))
	if err != nil {
		err = msgp.WrapError(err, "Info", "CreativeId")
		return
	}
	for za0005 := range z.Info.CreativeId {
		err = en.WriteInt(z.Info.CreativeId[za0005])
		if err != nil {
			err = msgp.WrapError(err, "Info", "CreativeId", za0005)
			return
		}
	}
	// write "4"
	err = en.Append(0xa1, 0x34)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Info.WhiskyId)))
	if err != nil {
		err = msgp.WrapError(err, "Info", "WhiskyId")
		return
	}
	for za0006 := range z.Info.WhiskyId {
		err = en.WriteInt(z.Info.WhiskyId[za0006])
		if err != nil {
			err = msgp.WrapError(err, "Info", "WhiskyId", za0006)
			return
		}
	}
	// write "5"
	err = en.Append(0xa1, 0x35)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Info.BudgetId)))
	if err != nil {
		err = msgp.WrapError(err, "Info", "BudgetId")
		return
	}
	for za0007 := range z.Info.BudgetId {
		err = en.WriteInt(z.Info.BudgetId[za0007])
		if err != nil {
			err = msgp.WrapError(err, "Info", "BudgetId", za0007)
			return
		}
	}
	// write "6"
	err = en.Append(0xa1, 0x36)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Info.UserId)))
	if err != nil {
		err = msgp.WrapError(err, "Info", "UserId")
		return
	}
	for za0008 := range z.Info.UserId {
		err = en.WriteInt(z.Info.UserId[za0008])
		if err != nil {
			err = msgp.WrapError(err, "Info", "UserId", za0008)
			return
		}
	}
	// write "3"
	// map header, size 3
	// write "1"
	err = en.Append(0xa1, 0x33, 0x83, 0xa1, 0x31)
	if err != nil {
		return
	}
	err = en.WriteString(z.Algorithm.Version)
	if err != nil {
		err = msgp.WrapError(err, "Algorithm", "Version")
		return
	}
	// write "2"
	err = en.Append(0xa1, 0x32)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Algorithm.GovernorOFF)
	if err != nil {
		err = msgp.WrapError(err, "Algorithm", "GovernorOFF")
		return
	}
	// write "3"
	err = en.Append(0xa1, 0x33)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Algorithm.StatRateOFF)
	if err != nil {
		err = msgp.WrapError(err, "Algorithm", "StatRateOFF")
		return
	}
	// write "4"
	// map header, size 1
	// write "1"
	err = en.Append(0xa1, 0x34, 0x81, 0xa1, 0x31)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Runtime.PanicON)
	if err != nil {
		err = msgp.WrapError(err, "Runtime", "PanicON")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RequestDebugParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "1"
	o = append(o, 0x84, 0xa1, 0x31)
	o = msgp.AppendMapHeader(o, uint32(len(z.Tags)))
	for za0001, za0002 := range z.Tags {
		o = msgp.AppendString(o, za0001)
		o, err = msgp.AppendIntf(o, za0002)
		if err != nil {
			err = msgp.WrapError(err, "Tags", za0001)
			return
		}
	}
	// string "2"
	// map header, size 6
	// string "1"
	o = append(o, 0xa1, 0x32, 0x86, 0xa1, 0x31)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Info.CampaignId)))
	for za0003 := range z.Info.CampaignId {
		o = msgp.AppendInt(o, z.Info.CampaignId[za0003])
	}
	// string "2"
	o = append(o, 0xa1, 0x32)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Info.PlanId)))
	for za0004 := range z.Info.PlanId {
		o = msgp.AppendInt(o, z.Info.PlanId[za0004])
	}
	// string "3"
	o = append(o, 0xa1, 0x33)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Info.CreativeId)))
	for za0005 := range z.Info.CreativeId {
		o = msgp.AppendInt(o, z.Info.CreativeId[za0005])
	}
	// string "4"
	o = append(o, 0xa1, 0x34)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Info.WhiskyId)))
	for za0006 := range z.Info.WhiskyId {
		o = msgp.AppendInt(o, z.Info.WhiskyId[za0006])
	}
	// string "5"
	o = append(o, 0xa1, 0x35)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Info.BudgetId)))
	for za0007 := range z.Info.BudgetId {
		o = msgp.AppendInt(o, z.Info.BudgetId[za0007])
	}
	// string "6"
	o = append(o, 0xa1, 0x36)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Info.UserId)))
	for za0008 := range z.Info.UserId {
		o = msgp.AppendInt(o, z.Info.UserId[za0008])
	}
	// string "3"
	// map header, size 3
	// string "1"
	o = append(o, 0xa1, 0x33, 0x83, 0xa1, 0x31)
	o = msgp.AppendString(o, z.Algorithm.Version)
	// string "2"
	o = append(o, 0xa1, 0x32)
	o = msgp.AppendBool(o, z.Algorithm.GovernorOFF)
	// string "3"
	o = append(o, 0xa1, 0x33)
	o = msgp.AppendBool(o, z.Algorithm.StatRateOFF)
	// string "4"
	// map header, size 1
	// string "1"
	o = append(o, 0xa1, 0x34, 0x81, 0xa1, 0x31)
	o = msgp.AppendBool(o, z.Runtime.PanicON)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RequestDebugParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Tags")
				return
			}
			if z.Tags == nil {
				z.Tags = make(map[string]interface{}, zb0002)
			} else if len(z.Tags) > 0 {
				for key := range z.Tags {
					delete(z.Tags, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 interface{}
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Tags")
					return
				}
				za0002, bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Tags", za0001)
					return
				}
				z.Tags[za0001] = za0002
			}
		case "2":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Info")
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Info")
					return
				}
				switch msgp.UnsafeString(field) {
				case "1":
					var zb0004 uint32
					zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Info", "CampaignId")
						return
					}
					if cap(z.Info.CampaignId) >= int(zb0004) {
						z.Info.CampaignId = (z.Info.CampaignId)[:zb0004]
					} else {
						z.Info.CampaignId = make([]int, zb0004)
					}
					for za0003 := range z.Info.CampaignId {
						z.Info.CampaignId[za0003], bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Info", "CampaignId", za0003)
							return
						}
					}
				case "2":
					var zb0005 uint32
					zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Info", "PlanId")
						return
					}
					if cap(z.Info.PlanId) >= int(zb0005) {
						z.Info.PlanId = (z.Info.PlanId)[:zb0005]
					} else {
						z.Info.PlanId = make([]int, zb0005)
					}
					for za0004 := range z.Info.PlanId {
						z.Info.PlanId[za0004], bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Info", "PlanId", za0004)
							return
						}
					}
				case "3":
					var zb0006 uint32
					zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Info", "CreativeId")
						return
					}
					if cap(z.Info.CreativeId) >= int(zb0006) {
						z.Info.CreativeId = (z.Info.CreativeId)[:zb0006]
					} else {
						z.Info.CreativeId = make([]int, zb0006)
					}
					for za0005 := range z.Info.CreativeId {
						z.Info.CreativeId[za0005], bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Info", "CreativeId", za0005)
							return
						}
					}
				case "4":
					var zb0007 uint32
					zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Info", "WhiskyId")
						return
					}
					if cap(z.Info.WhiskyId) >= int(zb0007) {
						z.Info.WhiskyId = (z.Info.WhiskyId)[:zb0007]
					} else {
						z.Info.WhiskyId = make([]int, zb0007)
					}
					for za0006 := range z.Info.WhiskyId {
						z.Info.WhiskyId[za0006], bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Info", "WhiskyId", za0006)
							return
						}
					}
				case "5":
					var zb0008 uint32
					zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Info", "BudgetId")
						return
					}
					if cap(z.Info.BudgetId) >= int(zb0008) {
						z.Info.BudgetId = (z.Info.BudgetId)[:zb0008]
					} else {
						z.Info.BudgetId = make([]int, zb0008)
					}
					for za0007 := range z.Info.BudgetId {
						z.Info.BudgetId[za0007], bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Info", "BudgetId", za0007)
							return
						}
					}
				case "6":
					var zb0009 uint32
					zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Info", "UserId")
						return
					}
					if cap(z.Info.UserId) >= int(zb0009) {
						z.Info.UserId = (z.Info.UserId)[:zb0009]
					} else {
						z.Info.UserId = make([]int, zb0009)
					}
					for za0008 := range z.Info.UserId {
						z.Info.UserId[za0008], bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Info", "UserId", za0008)
							return
						}
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Info")
						return
					}
				}
			}
		case "3":
			var zb0010 uint32
			zb0010, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Algorithm")
				return
			}
			for zb0010 > 0 {
				zb0010--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Algorithm")
					return
				}
				switch msgp.UnsafeString(field) {
				case "1":
					z.Algorithm.Version, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Algorithm", "Version")
						return
					}
				case "2":
					z.Algorithm.GovernorOFF, bts, err = msgp.ReadBoolBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Algorithm", "GovernorOFF")
						return
					}
				case "3":
					z.Algorithm.StatRateOFF, bts, err = msgp.ReadBoolBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Algorithm", "StatRateOFF")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Algorithm")
						return
					}
				}
			}
		case "4":
			var zb0011 uint32
			zb0011, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Runtime")
				return
			}
			for zb0011 > 0 {
				zb0011--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Runtime")
					return
				}
				switch msgp.UnsafeString(field) {
				case "1":
					z.Runtime.PanicON, bts, err = msgp.ReadBoolBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Runtime", "PanicON")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Runtime")
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RequestDebugParam) Msgsize() (s int) {
	s = 1 + 2 + msgp.MapHeaderSize
	if z.Tags != nil {
		for za0001, za0002 := range z.Tags {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.GuessSize(za0002)
		}
	}
	s += 2 + 1 + 2 + msgp.ArrayHeaderSize + (len(z.Info.CampaignId) * (msgp.IntSize)) + 2 + msgp.ArrayHeaderSize + (len(z.Info.PlanId) * (msgp.IntSize)) + 2 + msgp.ArrayHeaderSize + (len(z.Info.CreativeId) * (msgp.IntSize)) + 2 + msgp.ArrayHeaderSize + (len(z.Info.WhiskyId) * (msgp.IntSize)) + 2 + msgp.ArrayHeaderSize + (len(z.Info.BudgetId) * (msgp.IntSize)) + 2 + msgp.ArrayHeaderSize + (len(z.Info.UserId) * (msgp.IntSize)) + 2 + 1 + 2 + msgp.StringPrefixSize + len(z.Algorithm.Version) + 2 + msgp.BoolSize + 2 + msgp.BoolSize + 2 + 1 + 2 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ResponseDebugParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			z.Panic, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Panic")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ResponseDebugParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "1"
	err = en.Append(0x81, 0xa1, 0x31)
	if err != nil {
		return
	}
	err = en.WriteString(z.Panic)
	if err != nil {
		err = msgp.WrapError(err, "Panic")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ResponseDebugParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "1"
	o = append(o, 0x81, 0xa1, 0x31)
	o = msgp.AppendString(o, z.Panic)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ResponseDebugParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			z.Panic, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Panic")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ResponseDebugParam) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.Panic)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SourceInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "IpInt":
			z.IpInt, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "IpInt")
				return
			}
		case "Time":
			z.Time, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "Time")
				return
			}
		case "Date":
			z.Date, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Date")
				return
			}
		case "Weekday":
			z.Weekday, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Weekday")
				return
			}
		case "Hour":
			z.Hour, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Hour")
				return
			}
		case "Size":
			z.Size, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "Zone":
			z.Zone, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Zone")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SourceInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 7
	// write "IpInt"
	err = en.Append(0x87, 0xa5, 0x49, 0x70, 0x49, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.IpInt)
	if err != nil {
		err = msgp.WrapError(err, "IpInt")
		return
	}
	// write "Time"
	err = en.Append(0xa4, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.Time)
	if err != nil {
		err = msgp.WrapError(err, "Time")
		return
	}
	// write "Date"
	err = en.Append(0xa4, 0x44, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Date)
	if err != nil {
		err = msgp.WrapError(err, "Date")
		return
	}
	// write "Weekday"
	err = en.Append(0xa7, 0x57, 0x65, 0x65, 0x6b, 0x64, 0x61, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Weekday)
	if err != nil {
		err = msgp.WrapError(err, "Weekday")
		return
	}
	// write "Hour"
	err = en.Append(0xa4, 0x48, 0x6f, 0x75, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Hour)
	if err != nil {
		err = msgp.WrapError(err, "Hour")
		return
	}
	// write "Size"
	err = en.Append(0xa4, 0x53, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Size)
	if err != nil {
		err = msgp.WrapError(err, "Size")
		return
	}
	// write "Zone"
	err = en.Append(0xa4, 0x5a, 0x6f, 0x6e, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Zone)
	if err != nil {
		err = msgp.WrapError(err, "Zone")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SourceInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "IpInt"
	o = append(o, 0x87, 0xa5, 0x49, 0x70, 0x49, 0x6e, 0x74)
	o = msgp.AppendUint32(o, z.IpInt)
	// string "Time"
	o = append(o, 0xa4, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.Time)
	// string "Date"
	o = append(o, 0xa4, 0x44, 0x61, 0x74, 0x65)
	o = msgp.AppendInt(o, z.Date)
	// string "Weekday"
	o = append(o, 0xa7, 0x57, 0x65, 0x65, 0x6b, 0x64, 0x61, 0x79)
	o = msgp.AppendInt(o, z.Weekday)
	// string "Hour"
	o = append(o, 0xa4, 0x48, 0x6f, 0x75, 0x72)
	o = msgp.AppendInt(o, z.Hour)
	// string "Size"
	o = append(o, 0xa4, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt(o, z.Size)
	// string "Zone"
	o = append(o, 0xa4, 0x5a, 0x6f, 0x6e, 0x65)
	o = msgp.AppendString(o, z.Zone)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SourceInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "IpInt":
			z.IpInt, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IpInt")
				return
			}
		case "Time":
			z.Time, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Time")
				return
			}
		case "Date":
			z.Date, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Date")
				return
			}
		case "Weekday":
			z.Weekday, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Weekday")
				return
			}
		case "Hour":
			z.Hour, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hour")
				return
			}
		case "Size":
			z.Size, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "Zone":
			z.Zone, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Zone")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SourceInfo) Msgsize() (s int) {
	s = 1 + 6 + msgp.Uint32Size + 5 + msgp.TimeSize + 5 + msgp.IntSize + 8 + msgp.IntSize + 5 + msgp.IntSize + 5 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.Zone)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *UserInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			z.Age, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Age")
				return
			}
		case "2":
			z.Gender, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Gender")
				return
			}
		case "3":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "KeyWords")
				return
			}
			if cap(z.KeyWords) >= int(zb0002) {
				z.KeyWords = (z.KeyWords)[:zb0002]
			} else {
				z.KeyWords = make([]string, zb0002)
			}
			for za0001 := range z.KeyWords {
				z.KeyWords[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "KeyWords", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *UserInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "1"
	err = en.Append(0x83, 0xa1, 0x31)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Age)
	if err != nil {
		err = msgp.WrapError(err, "Age")
		return
	}
	// write "2"
	err = en.Append(0xa1, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Gender)
	if err != nil {
		err = msgp.WrapError(err, "Gender")
		return
	}
	// write "3"
	err = en.Append(0xa1, 0x33)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.KeyWords)))
	if err != nil {
		err = msgp.WrapError(err, "KeyWords")
		return
	}
	for za0001 := range z.KeyWords {
		err = en.WriteString(z.KeyWords[za0001])
		if err != nil {
			err = msgp.WrapError(err, "KeyWords", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *UserInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "1"
	o = append(o, 0x83, 0xa1, 0x31)
	o = msgp.AppendInt(o, z.Age)
	// string "2"
	o = append(o, 0xa1, 0x32)
	o = msgp.AppendInt(o, z.Gender)
	// string "3"
	o = append(o, 0xa1, 0x33)
	o = msgp.AppendArrayHeader(o, uint32(len(z.KeyWords)))
	for za0001 := range z.KeyWords {
		o = msgp.AppendString(o, z.KeyWords[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *UserInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "1":
			z.Age, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Age")
				return
			}
		case "2":
			z.Gender, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Gender")
				return
			}
		case "3":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "KeyWords")
				return
			}
			if cap(z.KeyWords) >= int(zb0002) {
				z.KeyWords = (z.KeyWords)[:zb0002]
			} else {
				z.KeyWords = make([]string, zb0002)
			}
			for za0001 := range z.KeyWords {
				z.KeyWords[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "KeyWords", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *UserInfo) Msgsize() (s int) {
	s = 1 + 2 + msgp.IntSize + 2 + msgp.IntSize + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.KeyWords {
		s += msgp.StringPrefixSize + len(z.KeyWords[za0001])
	}
	return
}
